.packageName <- "splm"
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/REmod.R"
REmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

## optimizing version 1:
    ##
    ## exploit ordering reversal
    ## and bdsmatrix functions as in ssrmod, sarsrmod, sarREmod...
    ##
    ## a) lag y etc.
    ## b) reverse ordering and exploit bds nature of vcov(e)
    ##
    ## maybe exploit analytical inverse of the submatrix block (gains on
    ## large-N problems)?? but how likely is it to have laaaarge T?

    ## extensive function rewriting, Giovanni Millo 04/10/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## bdsmatrix and solve.bdsmatrix are now imported
    
    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(1e-08)
    upper.bounds <- c(1e+09)

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    #wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    bSigma <- function(phipsi, n, t, w) {
        ## single block of the original *scaled* covariance
        ## maintain w for homogeneity with generic part
        Jt <- matrix(1, ncol = t, nrow = t)
        It <- diag(1, t)
        ## retrieve parms
        phi <- phipsi[1]
        ## psi not used: here passing 2 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        bSigma <- phi * Jt + It
        bSigma
    }
    detSigma <- function(phi, n, t) {
        detSigma <- -n/2 * log(t * phi + 1)
        detSigma
    }
    fullSigma <- function(phipsi, n, t, w) {
        sigma.i <- bSigma(phipsi, n, t, w)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(phipsi, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        phi <- phipsi[1]
        ## calc inverse sigma
        sigma <- fullSigma(phipsi, n, t, w)
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, y, sigma)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        due <- detSigma(phi, n, t)
        tre <- -n * t/2 * log(s2e)
        quattro <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic from here

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y unneeded here, keep parm for compatibility
    wy <- NULL

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t, w)
    beta <- GLSstepBDS(X, y, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))

    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp)
    covAR <- NULL
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])    
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="psi")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="psi")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/bsjktest.R"
`bsjktest` <-
function(x,...){
  UseMethod("bsjktest")
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/bsjktest.formula.R"
`bsjktest.formula` <-
function(x, data, index=NULL, listw, test=c("C.1","C.2","C.3","J"), ...){

  ## transform listw if needed
  if("listw" %in% class(listw)) {
    w <- listw2mat(listw)
  } else {
    w <- listw
  }

  ## transform data if needed
  if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  gindex <- dimnames(data)[[2]][1]
  tindex <- dimnames(data)[[2]][2]

  switch(match.arg(test), C.1 = {

    bsjk = pbsjkSDtest(formula=x, data=data, w=w, index=index, ...)

  }, C.2 = {

    bsjk = pbsjkARtest(formula=x, data=data, w=w, index=index, ...)

  }, C.3 = {

    stop("C.3 test not yet available")
    #bsjk = pbsjkREtest(formula=x, data=data, w=w, index=index, ...)

  }, J = {

    bsjk = pbsjkJtest(formula=x, data=data, w=w, index=index, ...)

  })

  return(bsjk)

}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/bsktest.R"
`bsktest` <-
function(x,...){
  UseMethod("bsktest")
}


#`bsktest.splm` <-
#function(x, listw, index=NULL, test=c("CLMlambda","CLMmu"), ...){
#	switch(match.arg(test), CLMlambda = {
#    bsk = clmltest.model(x,listw, index, ...)
#  }, CLMmu = {
#    bsk = clmmtest.model(x,listw, index, ... )
#  })
#  return(bsk)
#}

`bsktest.formula` <-
function(x, data, index=NULL, listw,
         test=c("LMH","LM1","LM2","CLMlambda","CLMmu"),
         standardize=TRUE, ...){
  

switch(match.arg(test), LM1 = {

    bsk = slm1test(x, data, index,  listw, standardize, ...)

  }, LM2 = {

    bsk = slm2test(x, data, index,  listw, standardize, ...)

  }, LMH = {

    bsk = LMHtest(x, data, index,  listw, ...)

  }, CLMlambda = {

    bsk = clmltest(x, data, index,  listw, ...)

  }, CLMmu = {

    bsk = clmmtest(x, data, index,  listw, ...)

  })

  return(bsk)

}




`clmltest.model` <-
function(x, listw, index, ...){
    ## depends on:
    ## listw2dgCMatrix.R
    ## REmod.R
    ## spreml.R
if(!inherits(x,"splm")) stop("argument should be an object of class splm")
frm<-x$call
if(x$type != "random effects ML") stop("argument should be of type random effects ML")

  if(is.null(index))  stop("index should be specified to retrieve information on time and cross-sectional dimentions")

  if(!inherits(listw,"listw")) stop("object w should be of class listw")



  ind <- index[,1]
  tind <- index[,2]

if(names(x$coefficients)[1]=="(Intercept)")  X<-data.frame(cbind(rep(1,ncol(x$model)), x$model[,-1]))
else X<-x$model[,-1]
  y<-x$model[,1]
  	eML<-x$residuals



  oo<-order(tind,ind)
  X<-X[oo,]
  y<-y[oo]
  N<-length(unique(ind))
  k<-dim(X)[[2]]
  T<-max(tapply(X[,1],ind,length))
  NT<-length(ind)
	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) 
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T)) 



	eme<-tapply(eML,inde1,mean)
	emme<-eML - rep(eme,T)
	sigmav<-crossprod(eML,emme)/(N*(T-1)) 
	sigma1<-crossprod(eML,rep(eme,T))/N 
	
	c1<-sigmav/sigma1^2
	c2<-1/sigmav
	c1e<-as.numeric(c1)*eML
	Ws<-listw2dgCMatrix(listw) 
	Wst<-t(Ws) 
	WpsW<-Wst+Ws

yybis<-function(q){
	wq<-(WpsW)%*%q
	wq<-as.matrix(wq)
	}

	Wc1e<-unlist(tapply(eML,inde,yybis)) 
	sumWc1e<-tapply(Wc1e,inde1,sum)
	prod1<-as.numeric(c1)*rep(sumWc1e,T)/T
	prod2<-as.numeric(c2)* (Wc1e - rep(sumWc1e,T)/T)
	prod<-prod1+prod2
	D<-1/2*crossprod(eML,prod) 

	W2<-Ws%*%Ws 
	WW<-crossprod(Ws) 
tr<-function(R) sum(diag(R))
	b<-tr(W2+WW) 
	LMl1<-D^2 / (((T-1)+as.numeric(sigmav)^2/as.numeric(sigma1)^2)*b) 

	LMlstar<-sqrt(LMl1) 
	statistics<-LMlstar
  pval <- 2*pnorm(LMlstar, lower.tail=FALSE)

  names(statistics)="LM*-lambda"
	method<- "Baltagi, Song and Koh LM*-lambda conditional LM test (assuming sigma^2_mu >= 0)"

  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Spatial autocorrelation")
  class(RVAL) <- "htest"
  return(RVAL)

}




`clmmtest.model` <-
function(x, listw, index, ...){

if(!inherits(x,"splm")) stop("argument should be an object of class splm")
frm<-x$call
if(x$type != "fixed effects error") stop("argument should be of type random effects ML")

  if(is.null(index))  stop("index should be specified to retrieve information on time and cross-sectional dimentions")

  if(!inherits(listw,"listw")) stop("object w should be of class listw")



  ind <- index[,1]
  tind <- index[,2]

if(names(x$coefficients)[1]=="(Intercept)")  X<-data.frame(cbind(rep(1,ncol(x$model)), x$model[,-1]))
else X<-x$model[,-1]
  y<-x$model[,1]
  	eML<-x$residuals

  oo<-order(tind,ind)
  X<-X[oo,]
  y<-y[oo]

  N<-length(unique(ind))
  k<-dim(X)[[2]]
  T<-max(tapply(X[,1],ind,length))
  NT<-length(ind)
	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) 
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T)) 

	lambda<-x$spat.coef

 	Ws<-listw2dgCMatrix(listw) 
	Wst<-t(Ws)  
	B<- Diagonal(N)-lambda*Ws

	
	BpB<-crossprod(B)
	BpB2 <- BpB %*% BpB
	BpBi<- solve(BpB)
tr<-function(R) sum(diag(R))
	trBpB<-tr(BpB)

vc<-function(R) {
	BBu<-BpB %*% R
	BBu<-as.matrix(BBu)
	}

	eme<-unlist(tapply(eML,inde,vc))

#	eme<-tapply(eML,inde1,mean)
#	emme<-eML - rep(eme,T)
#	
	sigmav2<-crossprod(eML,eme)/(N*T)
	sigmav4<-sigmav2^2


yybis<-function(q){ 
	wq<-rep(q,T)
	tmp<-wq%*%eML
					}
					
	BBu<-apply(BpB2,1,yybis)
	BBu<-rep(BBu,T)
	upBBu<-crossprod(eML,BBu)
	
	Dmu<- -(T/(2*sigmav2))*trBpB + (1/(2*sigmav4))*upBBu

	WpB<-Wst%*%B
	BpW<-crossprod(B, Ws)
	WpBplBpW <-WpB + BpW
	bigG<-WpBplBpW %*% BpBi
	
	smalle<-tr(BpB2)
	smalld<-tr(WpBplBpW)
	smallh<-trBpB
	smallg<-tr(bigG)
	smallc<-tr(bigG%*%bigG)
	
	NUM<- ((2 * sigmav4)/T) * ((N*sigmav4*smallc)-(sigmav4*smallg^2))   ###equation 2.30 in the paper
	DENft<- NT*sigmav4* smalle * smallc
	DENst<- N*sigmav4* smalld^2
	DENtt<- T*sigmav4* smallg^2 * smalle
	DENfot<- 2* sigmav4 *smallg * smallh* smalld
	DENfit<- sigmav4 * smallh^2* smallc
	DEN<- DENft - DENst - DENtt + DENfot - DENfit
	LMmu <- Dmu^2*NUM / DEN
	
	LMmustar<- sqrt(LMmu)
  
  statistics<-LMmustar
  pval <- 2*pnorm(LMmustar, lower.tail=FALSE)

  names(statistics)="LM*-mu"
	method<- "Baltagi, Song and Koh LM*- mu conditional LM test (assuming lambda may or may not be = 0)"
  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Random regional effects")
  class(RVAL) <- "htest"
  return(RVAL)

}




`slm1test` <-
function(formula, data, index=NULL, listw, standardize, ...){

  if(!is.null(index)) { ####can be deleted when using the wrapper
    #require(plm)
    data <- plm.data(data, index)
    }

  index <- data[,1]
  tindex <- data[,2]

  x<-model.matrix(formula,data=data)
  y<-model.response(model.frame(formula,data=data))
   cl<-match.call()
  
  names(index)<-row.names(data)
  ind<-index[which(names(index)%in%row.names(x))]
  tind<-tindex[which(names(index)%in%row.names(x))]
  oo<-order(tind,ind)
  x<-x[oo,]
  y<-y[oo]
  ind<-ind[oo]
  tind<-tind[oo]

  
  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)
	
	ols<-lm(y~x-1)
	XpXi<-solve(crossprod(x))
   n<-dim(ols$model)[1]

	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) ####indicator to get the cross-sectional observations
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T)) ####indicator to get the time periods observations

	bOLS<-coefficients(ols)
	e<-as.matrix(residuals(ols))
	ee<-crossprod(e)



		JIe<-tapply(e,inde1,sum)
		JIe<-rep(JIe,T) 
		G<-(crossprod(e,JIe)/ee)-1 
tr<-function(R) sum(diag(R))

		LM1<-sqrt((NT/(2*(T-1))))*as.numeric(G) 
		
		s<-NT-k 
		B<-XpXi%*%t(x)   
		
fun<-function(Q) tapply(Q,inde1,sum) 
		JIx<-apply(x,2,fun)
		JIX<-matrix(,NT,k)
for (i in 1:k) JIX[,i]<-rep(JIx[,i],T) ## "NOTE ON THE TRACE.R"
		di<-numeric(NT)
		XpJIX<-crossprod(x,JIX)
		d1<-NT-tr(XpJIX%*%XpXi) 
		Ed1<-d1/s 

		di2<-numeric(NT)
		JIJIx<-apply(JIX,2,fun)
		JIJIX<-matrix(,NT,k)
for (i in 1:k) JIJIX[,i]<-rep(JIJIx[,i],T)
		JIJIxxpx<-JIJIX%*%XpXi
		di1<- crossprod(x, JIJIxxpx)
		tr1<-tr(di1)
		XpIJX<-crossprod(x,JIX)
		fp<-XpIJX%*%B
		sp<-JIX%*%XpXi
		tr3<-tr(fp%*%sp)
		fintr<-NT*T-2*tr1+tr3 
		Vd1<-2*(s*fintr - (d1^2))/s^2*(s+2) 

SLM1<-((G+1)- Ed1)/sqrt(Vd1) 

  statistics <- if(standardize) SLM1 else LM1
  pval <- 2*pnorm(statistics, lower.tail=FALSE)
	
  names(statistics) <- if(standardize) "SLM1" else "LM1"
	method<- "Baltagi, Song and Koh SLM1 marginal test"
  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Random effects")
  class(RVAL) <- "htest"
  return(RVAL)
}


`slm2test` <-
function(formula, data, index=NULL, listw, standardize, ...){

  if(!is.null(index)) { 
    #require(plm)
    data <- plm.data(data, index)
    }

  index <- data[,1]
  tindex <- data[,2]

  x<-model.matrix(formula,data=data)
  y<-model.response(model.frame(formula,data=data))
   cl<-match.call()
	names(index)<-row.names(data)
  ind<-index[which(names(index)%in%row.names(x))]
  tind<-tindex[which(names(index)%in%row.names(x))]
  oo<-order(tind,ind)
  x<-x[oo,]
  y<-y[oo]
  ind<-ind[oo]
  tind<-tind[oo]

  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)
  ols<-lm(y~x-1)
	XpXi<-solve(crossprod(x))
   n<-dim(ols$model)[1]

	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) 
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T)) 
	
	bOLS<-coefficients(ols)
	e<-as.matrix(residuals(ols))
	ee<-crossprod(e)


		Ws<-listw2dgCMatrix(listw) 
		Wst<-t(Ws)  
		WWp<-(Ws+Wst)/2 

yy<-function(q){ 
	wq<-WWp%*%q
	wq<-as.matrix(wq)
	}

		IWWpe<-unlist(tapply(e,inde,yy)) 
		H<-crossprod(e,IWWpe)/crossprod(e) 
		W2<-Ws%*%Ws 
		WW<-crossprod(Ws) 
    tr<-function(R) sum(diag(R))
	b<-tr(W2+WW) 
		LM2<-sqrt((N^2*T)/b)*as.numeric(H)
		s<-NT-k
lag<-function(QQ)lag.listw(listw,QQ)
fun2<-function(Q) unlist(tapply(Q,inde,lag))
	Wx<-apply(x,2,fun2)
	WX<-matrix(Wx,NT,k)
	XpWx<-crossprod(x,WX)
	D2M<-XpWx%*%XpXi 
	Ed2<- (T*sum(diag(Ws)) - tr(D2M))/s 

	WWx<-apply(WX,2,fun2)
	WWX<-matrix(WWx,NT,k)
	XpWWX<-crossprod(x,WWX)				
	spb<-XpWWX%*%XpXi
	spbb<-tr(spb)
	tpb<-XpWx%*%XpXi%*%XpWx%*%XpXi
	fintr2<-T*tr(W2) - 2* spbb + tr(tpb)
	Vd2<-2*(s*fintr2 - (sum(diag(D2M))^2))/s^2*(s+2) 
	We<-unlist(tapply(e,inde,function(W) lag.listw(listw,W)))
	d2<-crossprod(e,We)/ee
	
	SLM2<- (d2-Ed2)/sqrt(Vd2) 
  
  statistics <- if(standardize) SLM2 else LM2
  pval <- 2*pnorm(statistics, lower.tail=FALSE)
	
  names(statistics) <- if(standardize) "SLM2" else "LM2"
  
	method<- "Baltagi, Song and Koh LM2 marginal test"
  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Spatial autocorrelation")
  class(RVAL) <- "htest"
  return(RVAL)
}


`LMHtest` <-
function(formula, data, index=NULL, listw, ...){
    ## depends on listw2dgCMatrix.R
  #require(ibdreg) # for mixed chisquare distribution
  # now imported
  if(!is.null(index)) { ####can be deleted when using the wrapper
    #require(plm)
    data <- plm.data(data, index)
    }

  index <- data[,1]
  tindex <- data[,2]

  x<-model.matrix(formula,data=data)
  y<-model.response(model.frame(formula,data=data))
  cl<-match.call()
  names(index)<-row.names(data)
  ind<-index[which(names(index)%in%row.names(x))]
  tind<-tindex[which(names(index)%in%row.names(x))]
  oo<-order(tind,ind)
  x<-x[oo,]
  y<-y[oo]
  ind<-ind[oo]
  tind<-tind[oo]

  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)
  ols<-lm(y~x-1)
	XpXi<-solve(crossprod(x))
   n<-dim(ols$model)[1]

	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) ####indicator to get the cross-sectional observations
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T)) ####indicator to get the time periods observations
	bOLS<-coefficients(ols)
	e<-as.matrix(residuals(ols))
	ee<-crossprod(e)


		JIe<-tapply(e,inde1,sum)
		JIe<-rep(JIe,T) 
		G<-(crossprod(e,JIe)/ee)-1 
      tr<-function(R) sum(diag(R))

		LM1<-sqrt((NT/(2*(T-1))))*as.numeric(G) 


####calculate the elements of LMj, LM1, SLM1
		Ws<-listw2dgCMatrix(listw) 
		Wst<-t(Ws)  
		WWp<-(Ws+Wst)/2 

yy<-function(q){
	wq<-WWp%*%q
	wq<-as.matrix(wq)
	}
	
		IWWpe<-unlist(tapply(e,inde,yy)) 
		H<-crossprod(e,IWWpe)/crossprod(e) 
		W2<-Ws%*%Ws 
		WW<-crossprod(Ws) 
      tr<-function(R) sum(diag(R))
	   b<-tr(W2+WW) 
		LM2<-sqrt((N^2*T)/b)*as.numeric(H)


if (LM1<=0){
		if (LM2<=0) JOINT<-0
		else JOINT<-LM2^2
		}		####this is chi-square_m in teh notation of the paper.

	else{
		if (LM2<=0) JOINT<-LM1^2
		else JOINT<-LM1^2 + LM2^2
		}
  statistics<-JOINT
  pval <- 1 - pchibar(statistics, df=0:2, wt=c(0.25,0.5,0.25))
    

  names(statistics)="LM-H"
	method<- "Baltagi, Song and Koh LM-H one-sided joint test"

  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Random Regional Effects and Spatial autocorrelation")
  class(RVAL) <- "htest"
  return(RVAL)
}


`clmmtest` <-
function(formula, data, index=NULL, listw, ...){

## print("uso questa")

ml <- spfeml(formula=formula, data=data, index=index, listw=listw, model="error", effects="pooled")
    ## spml(formula, data=data, index=index, listw, errors = "BSK", effects = "fixed", lag = FALSE, spatial.error = TRUE)

	 if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  index <- data[,1]
  tindex <- data[,2]
  X<-model.matrix(formula,data=data)
  y<-model.response(model.frame(formula,data=data))
  names(index)<-row.names(data)
  ind<-index[which(names(index)%in%row.names(X))]
  tind<-tindex[which(names(index)%in%row.names(X))]
  oo<-order(tind,ind)
  X<-X[oo,]
  y<-y[oo]
  ind<-ind[oo]
  tind<-tind[oo]
  N<-length(unique(ind))
  k<-dim(X)[[2]]
  T<-max(tapply(X[,1],ind,length))
  NT<-length(ind)


	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N))
	ind1<-seq(1,N)
	inde1<-as.numeric(rep(ind1,T))

	lambda<-ml$spat.coef
	eML<-residuals(ml)

 	Ws<-listw2dgCMatrix(listw)
	Wst<-t(Ws)
	B<- Diagonal(N)-lambda*Ws


	BpB<-crossprod(B)
	BpB2 <- BpB %*% BpB
	BpBi<- solve(BpB)
tr<-function(R) sum(diag(R))
	trBpB<-tr(BpB)

vc<-function(R) {
	BBu<-BpB %*% R
	BBu<-as.matrix(BBu)
	}

	eme<-unlist(tapply(eML,inde,vc))

#	eme<-tapply(eML,inde1,mean)
#	emme<-eML - rep(eme,T)
#
	sigmav2<-crossprod(eML,eme)/(N*T)
	sigmav4<-sigmav2^2


yybis<-function(q){
	wq<-rep(q,T)
	tmp<-wq%*%eML
					}

	BBu<-apply(BpB2,1,yybis)
	BBu<-rep(BBu,T)
	upBBu<-crossprod(eML,BBu)

	Dmu<- -(T/(2*sigmav2))*trBpB + (1/(2*sigmav4))*upBBu

	WpB<-Wst%*%B
	BpW<-crossprod(B, Ws)
	WpBplBpW <-WpB + BpW
	bigG<-WpBplBpW %*% BpBi

	smalle<-tr(BpB2)
	smalld<-tr(WpBplBpW)
	smallh<-trBpB
	smallg<-tr(bigG)
	smallc<-tr(bigG%*%bigG)

	NUM<- ((2 * sigmav4)/T) * ((N*sigmav4*smallc)-(sigmav4*smallg^2))   ###equation 2.30 in the paper
	DENft<- NT*sigmav4* smalle * smallc
	DENst<- N*sigmav4* smalld^2
	DENtt<- T*sigmav4* smallg^2 * smalle
	DENfot<- 2* sigmav4 *smallg * smallh* smalld
	DENfit<- sigmav4 * smallh^2* smallc
	DEN<- DENft - DENst - DENtt + DENfot - DENfit
	LMmu <- Dmu^2*NUM / DEN

	LMmustar<- sqrt(LMmu)

  statistics<-LMmustar
  pval <- 2*pnorm(LMmustar, lower.tail=FALSE)

  names(statistics)="LM*-mu"
	method<- "Baltagi, Song and Koh LM*- mu conditional LM test (assuming lambda may or may not be = 0)"
  dname <- deparse(formula)
  RVAL <- list(statistic = statistics,
               method = method,
               p.value = pval, data.name=deparse(formula), alternative="Random regional effects")
  class(RVAL) <- "htest"
  return(RVAL)

}


clmltest <- function (formula, data, index = NULL, listw)
{
   # ml <- spreml(formula, data = data, w = listw2mat(listw),
   #     errors = "re")
    if (!is.null(index)) {
        #require(plm)
        data <- plm.data(data, index)
    }
    index <- data[, 1]
    tindex <- data[, 2]
    data$tindex <- tindex

ml <- lme(formula, data, random=~1|tindex)

    X <- model.matrix(formula, data = data)
    y <- model.response(model.frame(formula, data = data))
    names(index) <- row.names(data)
    ind <- index[which(names(index) %in% row.names(X))]
    tind <- tindex[which(names(index) %in% row.names(X))]
    oo <- order(tind, ind)
    X <- X[oo, ]
    y <- y[oo]
    ind <- ind[oo]
    tind <- tind[oo]
    N <- length(unique(ind))
    k <- dim(X)[[2]]
    T <- max(tapply(X[, 1], ind, length))
    NT <- length(ind)
    eML <- residuals(ml)
    indic <- seq(1, T)
    inde <- as.numeric(rep(indic, each = N))
    ind1 <- seq(1, N)
    inde1 <- as.numeric(rep(ind1, T))
    eme <- tapply(eML, inde1, mean)
    emme <- eML - rep(eme, T)
    sigmav <- crossprod(eML, emme)/(N * (T - 1))
    sigma1 <- crossprod(eML, rep(eme, T))/N
    c1 <- sigmav/sigma1^2
    c2 <- 1/sigmav
    c1e <- as.numeric(c1) * eML
    Wst <- listw2dgCMatrix(listw)
    Ws <- t(Wst)
    WpsW <- Wst + Ws
    yybis <- function(q) {
        wq <- (WpsW) %*% q
        wq <- as.matrix(wq)
    }
    Wc1e <- unlist(tapply(eML, inde, yybis))
    sumWc1e <- tapply(Wc1e, inde1, sum)
    prod1 <- as.numeric(c1) * rep(sumWc1e, T)/T
    prod2 <- as.numeric(c2) * (Wc1e - rep(sumWc1e, T)/T)
    prod <- prod1 + prod2
    D <- 1/2 * crossprod(eML, prod)
    W2 <- Ws %*% Ws
    WW <- crossprod(Ws)
    tr <- function(R) sum(diag(R))
    b <- tr(W2 + WW)
    LMl1 <- D^2/(((T - 1) + as.numeric(sigmav)^2/as.numeric(sigma1)^2) *
        b)
    LMlstar <- sqrt(LMl1)
    statistics <- LMlstar
    pval <- 2*pnorm(LMlstar, lower.tail = FALSE)
    names(statistics) = "LM*-lambda"
    method <- "Baltagi, Song and Koh LM*-lambda conditional LM test (assuming sigma^2_mu >= 0)"
    dname <- deparse(formula)
    RVAL <- list(statistic = statistics, method = method, p.value = pval,
        data.name = deparse(formula), alternative = "Spatial autocorrelation")
    class(RVAL) <- "htest"
    return(RVAL)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/fixed_effects.R"
feerror<-function(env, beta,sige, effects, method,rho, legacy){

	y<-get("y", envir = env)
	x<-get("x", envir = env)
	

	yt<-get("yt", envir = env)
	xt<-get("xt", envir = env)	
	N<-get("n", envir = env)
	T<-get("T", envir = env)
	NT<-get("NT", envir = env)
	k<-get("k", envir = env)
	listw<-get("listw", envir = env)
	inde<-get("inde", envir = env)


mx<-apply(x,2,mean)
intercept<-mean(y)-mx%*%beta
if (effects =="spfe"){
	ysms<-get("ysms", envir = env)
	xsms<-get("xsms", envir = env)

	sige<-as.numeric(sige)
	res.sfe <- as.matrix(ysms) - xsms %*% as.matrix(beta) - as.numeric(intercept)
	xhat <- x %*% as.matrix(beta) + rep(res.sfe,T) + as.numeric(intercept)
	res.var.sfe<- (sige / T)  + (as.numeric(sige)*(xsms%*% solve(crossprod(xt)) %*% t(xsms)))
	res.se.sfe<-sqrt(diag(res.var.sfe))
	res.t.sfe <- res.sfe / res.se.sfe 
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% 	solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	N.vars <- k + N
	res.e <- y - xhat
	FE.out<-list(res.sfe=res.sfe, res.se.sfe=res.se.sfe, intercept=intercept, res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
	}
	
if (effects== "tpfe")	{
	
	ytms<-get("ytms", envir = env)
	xtms<-get("xtms", envir = env)

 	sige<-as.numeric(sige)
	res.tfe <- as.matrix(ytms) - xtms %*% as.matrix(beta) - as.numeric(intercept)
	xhat <- x %*% as.matrix(beta) + rep(res.tfe,each=N) + as.numeric(intercept)
	res.var.tfe <- (sige / N)  + (as.numeric(sige)*(xtms%*% solve(crossprod(xt)) %*% t(xtms)))
	res.se.tfe <-sqrt(diag(res.var.tfe))
	res.t.tfe <- res.tfe/res.se.tfe
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% 	solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	N.vars <- k + T
		res.e <- y - xhat
		FE.out<-list(res.tfe=res.tfe, res.se.tfe=res.se.tfe, intercept=intercept, res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
		}
		
if (effects== "sptpfe"){
	
	ysms<-get("ysms", envir = env)
	xsms<-get("xsms", envir = env)

	ytms<-get("ytms", envir = env)
	xtms<-get("xtms", envir = env)

	sige<-as.numeric(sige)
	res.sfe <- as.matrix(ysms) - xsms %*% as.matrix(beta) - as.numeric(intercept)
	res.tfe <- as.matrix(ytms) - xtms %*% as.matrix(beta) - as.numeric(intercept)
		res.var.sfe<- (sige / T)  + (as.numeric(sige)*(xsms%*% solve(crossprod(xt)) %*% t(xsms)))
	res.se.sfe <-sqrt(diag(res.var.sfe))
	res.var.tfe <- (sige / N)  + (as.numeric(sige)*(xtms%*% solve(crossprod(xt)) %*% t(xtms)))
	res.se.tfe<-sqrt(diag(res.var.tfe))
	res.t.sfe <- res.sfe / res.se.sfe
	res.t.tfe <- res.tfe / res.se.tfe
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	xhat<- x %*% as.matrix(beta) + rep(res.sfe,T) + rep(res.tfe,each=N) + as.numeric(intercept)
	N.vars <- k + N + T - 1
	res.e <- y - xhat
FE.out<-list(res.tfe=res.tfe, res.se.tfe=res.se.tfe, res.sfe=res.sfe, res.se.sfe=res.se.sfe, intercept=intercept, res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
		}
		
if (effects=="pooled") {
	xhat <-   x %*% as.matrix(beta)
	res.e <- y - xhat
	FE.out<-list(xhat=xhat,N.vars=k,res.e=res.e)
	}

	yhat <- xhat
	ywhat <-  xt %*% beta
	r1 <- as.matrix(yt - mean(yt))
	r2 <- as.matrix(ywhat - mean(ywhat))
	r1r2 <- crossprod(r1,r2)
	r1r1 <- crossprod(r1)
	r2r2 <- crossprod(r2)
	res.corr <- as.numeric(r1r2^2) / (as.numeric(r1r1)*as.numeric(r2r2))
	
FE.out <- list(FE.out, res.corr=res.corr)
	}
	
#felag<-function(y,x,wy,ysms,xsms,ytms, xtms, wytms, wysms, beta,sige,yt,xt,N,T,NT,k,effects,method, rho,listw,inde){

felag<-function(env, beta,sige, effects, method, lambda, legacy, zero.policy){
	y<-get("y", envir = env)
	x<-get("x", envir = env)
	wy<-get("wy", envir = env)
	

	yt<-get("yt", envir = env)
	xt<-get("xt", envir = env)	
	N<-get("n", envir = env)
	T<-get("T", envir = env)
	NT<-get("NT", envir = env)
	k<-get("k", envir = env)
	listw<-get("listw", envir = env)
	inde<-get("inde", envir = env)
		
		mx<-apply(x,2,mean)
		intercept <- mean(y)- mean(wy)*lambda -  mx%*%beta

if (effects=="spfe"){
	ysms<-get("ysms", envir = env)
	xsms<-get("xsms", envir = env)
	wysms<-get("wysms", envir = env)

	res.sfe <- as.matrix(ysms) - as.matrix(wysms) *lambda - xsms %*% as.matrix(beta) - as.numeric(intercept)
	xhat <- x %*% as.matrix(beta) + rep(res.sfe,T) + as.numeric(intercept)
	res.var.sfe<- (sige / T)  + diag((as.numeric(sige)*(xsms%*% solve(crossprod(xt)) %*% t(xsms))))
	res.se.sfe<-sqrt(res.var.sfe)
	res.t.sfe <- res.sfe / res.se.sfe 
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% 	solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	N.vars <- k + N
	res.e <- y - xhat - lambda* wy
FE.out<-list(res.sfe=res.sfe, res.se.sfe=res.se.sfe, intercept=intercept, 	res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
	}
	
if (effects== "tpfe")	{
	ytms<-get("ytms", envir = env)
	xtms<-get("xtms", envir = env)
	wytms<-get("wytms", envir = env)	

	res.tfe <- as.matrix(ytms) - as.matrix(wytms)* lambda - xtms %*% as.matrix(beta) - as.numeric(intercept)
	xhat <- x %*% as.matrix(beta) + rep(res.tfe,each=N) + as.numeric(intercept)
	res.var.tfe <- (sige / N)  + (as.numeric(sige)*(xtms%*% solve(crossprod(xt)) %*% t(xtms)))
	res.se.tfe <-sqrt(diag(res.var.tfe))
	res.t.tfe <- res.tfe/res.se.tfe
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% 	solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	N.vars <- k + T
	res.e <- y - xhat - lambda * wy
FE.out<-list(res.tfe=res.tfe, res.se.tfe=res.se.tfe, intercept=intercept, 	res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
		}
if (effects== "sptpfe"){
	ysms<-get("ysms", envir = env)
	xsms<-get("xsms", envir = env)
	wysms<-get("wysms", envir = env)

	ytms<-get("ytms", envir = env)
	xtms<-get("xtms", envir = env)
	wytms<-get("wytms", envir = env)	

	res.sfe <- as.matrix(ysms) - as.matrix(wysms) * lambda - xsms %*% as.matrix(beta) - as.numeric(intercept)
	res.tfe <- as.matrix(ytms) - as.matrix(wytms) * lambda - xtms %*% as.matrix(beta) - as.numeric(intercept)
	res.var.sfe<- (sige / T)  + (as.numeric(sige)*(xsms%*% solve(crossprod(xt)) %*% t(xsms)))
	res.se.sfe <-sqrt(diag(res.var.sfe))
	res.var.tfe <- (sige / N)  + (as.numeric(sige)*(xtms%*% solve(crossprod(xt)) %*% t(xtms)))
	res.se.tfe<-sqrt(diag(res.var.tfe))
	res.t.sfe <- res.sfe / res.se.sfe
	res.t.tfe <- res.tfe / res.se.tfe
	res.se.con<-sqrt(as.numeric(sige) / NT + as.numeric(sige) * t(as.matrix(mx)) %*% solve(crossprod(xt)) %*% as.matrix(mx))
	res.t.con <- as.numeric(intercept) / res.se.con
	xhat<- x %*% as.matrix(beta) + rep(res.sfe,T) + rep(res.tfe,each=N) + as.numeric(intercept)
	N.vars <- k + N + T - 1
	res.e <- y - xhat - lambda * wy
FE.out<-list(res.tfe=res.tfe, res.se.tfe=res.se.tfe, res.sfe=res.sfe, res.se.sfe=res.se.sfe, intercept=intercept, res.se.con=res.se.con,xhat=xhat,N.vars=N.vars,res.e=res.e)
		}
if (effects=="pooled") {
	xhat <-   x %*% as.matrix(beta)
	res.e <- y - xhat - lambda* wy
	FE.out<-list(xhat=xhat,N.vars=k,res.e=res.e)
	}

if(legacy){
	W <- listw2dgCMatrix(listw, zero.policy = zero.policy)
	IrW<- sparseMatrix(i=1:N, j=1:N, x=1) -lambda*W
	IrWi<-solve(IrW)
	xtb <- xt %*% beta
	yhat <- unlist(tapply(xhat,inde, function(u) IrWi %*% u))
	ywhat <- unlist(tapply(xtb,inde, function(u) IrWi %*% u))
	r1 <- as.matrix(yt - mean(yt))
	r2 <- as.matrix(ywhat - mean(ywhat))
	r1r2 <- crossprod(r1,r2)
	r1r1 <- crossprod(r1)
	r2r2 <- crossprod(r2)
	res.corr <- as.numeric(r1r2^2) / (as.numeric(r1r1)*as.numeric(r2r2))
}
else res.corr <- NULL  

FE.out <- list(FE.out, res.corr=res.corr)
FE.out
	}
	
	
	
effects.splm<-function(object,...){
	x<-object
	if (class(x) != "splm") stop(paste("methos not implemented for objects of class", class(x)))
	if (class(x) != "splm" && (x$type != "fixed effects lag" || x$type != "fixed effects error")) stop(paste("methos not implemented for objects of type", x$type))
	all.FE<-x$res.eff[[1]]
	effects <- x$effects
if (effects=="pooled") stop("No fixed effects available if effects == pooled")
if(effects=="spfe"){
	INT <- all.FE$intercept
	se.INT<- all.FE$res.se.con
	z <- INT/se.INT
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   INTTable <- cbind(INT,se.INT,z,p)
	colnames(INTTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
	rownames(INTTable) <- "(Intercept)"
	SP.EFF <- all.FE$res.sfe
	se.SP.EFF <- all.FE$res.se.sfe 
	z <- SP.EFF/se.SP.EFF
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   SETable <- cbind(SP.EFF,se.SP.EFF,z,p)
	colnames(SETable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
res<-list(INTTable=INTTable,SETable=SETable, effects=effects)
	}
if(effects=="tpfe"){
	INT <- all.FE$intercept
	se.INT<- all.FE$res.se.con
	z <- INT/se.INT
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   INTTable <- cbind(INT,se.INT,z,p)
	colnames(INTTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
	rownames(INTTable) <- "(Intercept)"
	TP.EFF <- all.FE$res.tfe
	se.TP.EFF <- all.FE$res.se.tfe 
	z <- TP.EFF/se.TP.EFF
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   TETable <- cbind(TP.EFF,se.TP.EFF,z,p)
	colnames(TETable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
res<-list(INTTable=INTTable,TETable=TETable,effects=effects)
	}
if(effects=="sptpfe"){
	INT <- all.FE$intercept
	se.INT<- all.FE$res.se.con
	z <- INT/se.INT
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   INTTable <- cbind(INT,se.INT,z,p)
	colnames(INTTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
	rownames(INTTable) <- "(Intercept)"
	SP.EFF <- all.FE$res.sfe
	se.SP.EFF <- all.FE$res.se.sfe 
	z <- SP.EFF/se.SP.EFF
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   SETable <- cbind(SP.EFF,se.SP.EFF,z,p)
	colnames(SETable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
		TP.EFF <- all.FE$res.tfe
	se.TP.EFF <- all.FE$res.se.tfe 
	z <- TP.EFF/se.TP.EFF
   p <- 2*pnorm(abs(z),lower.tail=FALSE)
   TETable <- cbind(TP.EFF,se.TP.EFF,z,p)
	colnames(TETable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
res<-list(INTTable=INTTable,SETable=SETable,TETable=TETable,effects=effects)
	}
res
class(res) <- "effects.splm"
return(res)
	}
	
	
print.effects.splm <-
function(x,digits= max(3, getOption("digits") - 2),
...){
	object<-x
	effects<-object$effects
if(effects=="tpfe"){
	  cat("\nIntercept:\n")
  printCoefmat(object$INTTable,digits=digits, signif.legend=FALSE)

 cat("\n")  

	  cat("\nTime period fixed effects:\n")
  printCoefmat(object$TETable,digits=digits)

out<-rbind(object$INTTable,object$TETable)
}
	
if(effects=="spfe"){
	  cat("\nIntercept:\n")
  printCoefmat(object$INTTable,digits=digits,signif.legend=FALSE)

 cat("\n")  
 
	  cat("\nSpatial fixed effects:\n")
  printCoefmat(object$SETable,digits=digits)


out<-rbind(object$INTTable,object$SETable)
}
if(effects=="sptpfe"){
	  cat("\nIntercept:\n")
  printCoefmat(object$INTTable,digits=digits,signif.legend=FALSE)

 cat("\n")  
 
	  cat("\nSpatial fixed effects:\n")
  printCoefmat(object$SETable,digits=digits,signif.legend=FALSE)
 
  cat("\n")  
   
  	  cat("\nTime period fixed effects:\n")
  printCoefmat(object$TETable,digits=digits)

out<-rbind(object$INTTable,object$SETable,object$TETable)
}
	}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/impacts.splm.R"
impacts.splm<-function(obj, listw = NULL, time = NULL, ..., tr=NULL, R=200, type="mult", empirical=FALSE, Q=NULL){

if(is.null(listw) && is.null(tr)) stop("either listw or tr should be provided")

	
if(!is.null(listw) ){	
	if(listw$style != "W") stop("Only row-standardised weights supported")
	if(is.null(time) && is.null(tr)) stop("time periods should be provided")
}


if(is.null(tr)){
	
sparse.W <- listw2dgCMatrix(listw)
s.lws <- kronecker(Diagonal(time) , sparse.W)
tr <- trW(s.lws, type= type)
	
	}
	
if(is.na(match(obj$type, c("fixed effects lag","fixed effects sarar","random effects ML", "fixed effects GM","lag GM","fixed effects GM")))) stop("object type not recognized")
	
	if(obj$type == "fixed effects lag"){
		
class(obj)<- "gmsar"	
obj$type <- "SARAR"
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2
obj$secstep_var <- obj$vcov
imp <- impacts(obj, tr=tr, R=R, ...)

	}
	
	if(obj$type == "fixed effects sarar"){

class(obj)<- "gmsar"	
obj$type <- "SARAR"
rho <- obj$coefficients[2]
obj$coefficients <- obj$coefficients[-2]
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2
obj$secstep_var <- obj$vcov[-2,-2]
imp <- impacts(obj, tr=tr, R=R,...)		
		
	}

	if(obj$type == "fixed effects error") stop("Impacts Estimates are not available for Error Model")

	if(obj$type == "random effects ML")	{

if(!is.null(obj$arcoef)) {
class(obj)<- "gmsar"	
obj$type <- "SARAR"

obj$coefficients <- c(obj$arcoef, obj$coefficients)
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2
obj$secstep_var <- matrix(0,nrow(obj$vcov)+1,nrow(obj$vcov)+1)
obj$secstep_var[1,1] <- obj$vcov.arcoef
obj$secstep_var[(2:(nrow(obj$vcov)+1)),(2:(nrow(obj$vcov)+1))] <- obj$vcov
imp <- impacts(obj, tr=tr, R=R, ...)		
		}
		else stop("Impacts Estimates are not available for Error Model")		
		
	}
	

	if(obj$type == "fixed effects GM"){
		
		if(is.null(obj$endog)) {
obj$secstep_var <- vcov(obj)			
class(obj)<- "gmsar"	
obj$type <- "SARAR"
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2

imp <- impacts(obj, tr=tr, R=R, ...)		
			
			
		}
				
		else stop("No impacts estimates when endogenous variables are present in the system")
					
	}

if(obj$type == "lag GM")			{
	
		if(is.null(obj$endog)) {

class(obj)<- "gmsar"	
obj$type <- "SARAR"
obj$secstep_var <- obj$var			
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2

imp <- impacts(obj, tr=tr, R=R, ...)		
			
			
		}
				
		else stop("No impacts estimates when endogenous variables are present in the system")
					

	
}


if(obj$type == "random effects GM")			{
	
		if(is.null(obj$endog)) {

class(obj)<- "gmsar"	
obj$type <- "SARAR"
obj$secstep_var <- obj$vcov			
obj$data <- as.vector(obj$model)
obj$s2 <- obj$sigma2

imp <- impacts(obj, tr=tr, R=R, ...)		
			
			
		}
				
		else stop("No impacts estimates when endogenous variables are present in the system")
					

	
}
		



	
return(imp)	
	
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ivplm.b2sls.R"
###### between 2sls

ivplm.b2sls <- function(Y,X,H = NULL, endog = NULL, lag=FALSE, listw, lag.instruments, T = T, N = N, NT = NT, twow = FALSE, listw2 = NULL){

indic <- rep(1:N,T)

##transform y	
ybetween<-panel.transformations(Y,indic, type= "between")
ndim <- length(ybetween)
listwnn <- listw[1:ndim, 1:ndim]

Xbetween<-panel.transformations(X,indic, type= "between")
colnames(Xbetween)<-colnames(X)

if (colnames(Xbetween)[1] == "(Intercept)") Xbetween<-Xbetween[,-1]
delb<-as.numeric(which(diag(var(Xbetween))==0))
if(length(delb)==0) Xbetween<-Xbetween
else Xbetween<-Xbetween[,-delb]

if (colnames(X)[1] == "(Intercept)") Xbetween<-cbind(1,Xbetween)
colnames(Xbetween)[1]<-"(Intercept)"

if(!lag){
##transform the instruments H and the endogenous variable
	Hbetween<-panel.transformations(H,indic, type= "between")

	if(lag.instruments ) {
	
	L.Hbetween <- listwnn %*% Hbetween
	L2.Hbetween <- listwnn %*% L.Hbetween
	Hbetween <- cbind(Hbetween, as.matrix(L.Hbetween), as.matrix(L2.Hbetween))
}

	endogbetween<-panel.transformations(endog,indic, type= "between")
   colnames(endogbetween)<-colnames(endog)

res <-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*endogbetween, sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )
res$Hbetween <- Hbetween
}

else{
	
	wybetween <- listwnn %*% as.matrix(ybetween)
	wybetween <- as.matrix(wybetween)
    colnames(wybetween) <- ("lambda")
	
	if(is.null(endog)){
		
		            if(twow){
		            	
     listw2nn <- listw2[1:ndim, 1:ndim]       	
	WXbetween <- listwnn %*%  Xbetween
    WWXbetween <- listwnn %*% WXbetween
	W2Xbetween <- listw2nn %*%  Xbetween
    W2WXbetween <- listw2nn %*% WXbetween
    W2WWXbetween <- listw2nn %*% WWXbetween
            	
 	Hbetween <-cbind(as.matrix(WXbetween), as.matrix(WWXbetween), as.matrix(W2Xbetween), as.matrix(W2WXbetween), as.matrix(W2WWXbetween))            	
    
            }
else{            
	
            WXbetween <- as.matrix(listwnn %*% Xbetween)
            WWXbetween <- as.matrix(listwnn %*% WXbetween)
        
Hbetween<-cbind(WXbetween, WWXbetween)        
 	
 	}


res<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(wybetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )
res$Hbetween <- Hbetween
		}
		
else{
	
		Hbetween <- panel.transformations(H,indic, type= "between") 
			
if(lag.instruments ) {
	
	L.Hbetween <- listwnn %*% Hbetween
	L2.Hbetween <- listwnn %*% L.Hbetween

	if(twow){
		listw2nn <- listw2[1:ndim, 1:ndim] 
		w2.Hbetween <- as.matrix(listw2nn %*% Hbetween)
		w2w.Hbetween <- as.matrix(listw2nn %*% L.Hbetween)
		w2ww.Hbetween <- as.matrix(listw2nn %*% L2.Hbetween)
	Hbetween <- cbind(Hbetween, as.matrix(L.Hbetween), as.matrix(L2.Hbetween), w2.Hbetween, w2w.Hbetween, w2ww.Hbetween)		
	
	}
	
	else 		Hbetween <- cbind(Hbetween, as.matrix(L.Hbetween), as.matrix(L2.Hbetween))
}


            if(twow){
    listw2nn <- listw2[1:ndim, 1:ndim]        	
	WXbetween <- listwnn %*%  Xbetween
    WWXbetween <- listwnn %*% WXbetween
	W2Xbetween <- listw2nn %*%  Xbetween
    W2WXbetween <- listw2nn %*% WXbetween
    W2WWXbetween <- listw2nn %*% WWXbetween
            	
 	Hbetween <-cbind(Hbetween, as.matrix(WXbetween), as.matrix(WWXbetween), as.matrix(W2Xbetween), as.matrix(W2WXbetween), as.matrix(W2WWXbetween))            	
    
            }
else{            
	
	WXbetween <- listwnn %*%  Xbetween
    WWXbetween <- listwnn %*% WXbetween
 	Hbetween <-cbind(Hbetween, as.matrix(WXbetween), as.matrix(WWXbetween))
 	
 	}


	##transform the endogenous variables endog
	endogbetween<-panel.transformations(endog,indic, type= "between")
	endogbetween<-cbind(endogbetween, wybetween)

colnames(endogbetween)<-c(colnames(endog), "lambda")


	
res<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*endogbetween, sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )
res$Hbetween <- Hbetween
	}			
	}	

res
}




#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ivplm.ec2sls.R"

# # # # # ec 2sls

ivplm.ec2sls <- function(Y,X,H = NULL, endog = NULL, lag=FALSE, listw, lag.instruments, T = T, N = N, NT = NT ){

indic <- rep(1:N,T)
listwnn <- listw[1:N, 1:N]

##transform y	
transy<-panel.transformations(Y,indic, type= "both")
ybetween<-transy[[2]]
ywithin<-transy[[1]]
ybetweennt<- rep(ybetween, T)	

##transform X	
transx<-panel.transformations(X,indic, type= "both")
Xbetween<-transx[[2]]
Xwithin<-transx[[1]]
colnames(Xwithin)<-colnames(X)
colnames(Xbetween)<-colnames(X)
Xbetweennt<-matrix(,NT, ncol(Xbetween))
for (i in 1:ncol(Xbetween)) Xbetweennt[,i]<-rep(Xbetween[,i], T)
del<- which(diag(var(Xwithin))==0)
colnames(Xbetweennt)<-colnames(X)

if(!lag){
##transform the instruments H
transH<-panel.transformations(H,indic, type= "both")
Hbetween<-transH[[2]]
Hwithin<-transH[[1]]

if(lag.instruments ) {
	
	L.Hwithin <- listw %*% Hwithin
	L2.Hwithin <- listw %*% L.Hwithin
	Hwithin <- cbind(Hwithin, as.matrix(L.Hwithin), as.matrix(L2.Hwithin))

	L.Hbetween <- listwnn %*% Hbetween
	L2.Hbetween <- listwnn %*% L.Hbetween
	Hbetween <- cbind(Hbetween, as.matrix(L.Hbetween), as.matrix(L2.Hbetween))
	
}

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i],T)


##transform the endogenous variables endog
transendog<-panel.transformations(endog,indic, type= "both")
endogbetween<-transendog[[2]]
endogwithin<-transendog[[1]]
endogbetweennt<-matrix(,NT, ncol(endogbetween))
for (i in 1:ncol(endogbetween)) endogbetweennt[,i]<-rep(endogbetween[,i],T)
colnames(endogbetweennt)<-colnames(endog)
colnames(endogwithin)<-colnames(endog)

#W2SLS
resw<-spgm.tsls(as.matrix(ywithin), endogwithin, Xwithin, Hwithin )

sigma2v1<-resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - ncol(endogwithin)) 

#B2SLS
resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(endogbetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )

sigma21<-resb$sse /  resb$df

ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
endogstar<-endogwithin/sqrt(sigma2v1) + endogbetweennt/sqrt(sigma21)

Hins <- cbind(Xwithin,Xbetweennt,Hwithin,Hbetweennt)
res<-spgm.tsls(ystar, endogstar, xstar, Hinst = Hins, instr = TRUE )
res$sigma1<-sigma21
res$sigmav<-sigma2v1

}


else{
	
     wy <- listw %*%  Y

	  wywithin <- listw %*% ywithin
     wywithin <- as.matrix(wywithin)
     colnames(wywithin)<-"lambda"
     
  	  wybetween <- listwnn %*% as.matrix(ybetween)
     colnames(wybetween) <- ("lambda")
           
           WXwithin <- as.matrix(listw %*% Xwithin)
           WWXwithin <- as.matrix(listw %*%  WXwithin)

            WXbetween <- as.matrix(listwnn %*% Xbetween)
            WWXbetween <- as.matrix(listwnn %*% WXbetween)

if(is.null(endog)){

Hwithin<-cbind(WXwithin, WWXwithin)        
resw<-spgm.tsls(ywithin, wywithin, Xwithin, Hwithin)

sigma2v1<- resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - 1) 

        
Hbetween<-cbind(WXbetween, WWXbetween)        

resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(wybetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )
sigma21<-resb$sse /  resb$df

ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
endogstar<-wywithin/sqrt(sigma2v1) + rep(as.matrix(wybetween), T)/sqrt(as.numeric(sigma21))
endogstar<-as.matrix(endogstar)
colnames(endogstar)<-"lambda"


Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i],T)

A <- cbind(1, Xwithin, Xbetweennt, Hwithin, Hbetweennt)

res <- spgm.tsls(ystar, endogstar, xstar, Hinst = A, instr = TRUE)

res$sigma1 <- sigma21
res$sigmav <- sigma2v1
}	

else{

transH <- panel.transformations(H,indic, type= "both")
Hbetween <- transH[[2]]
Hwithin<-transH[[1]]

if(lag.instruments ) {
	
	L.Hwithin <- as.matrix(listw %*% Hwithin)
	L2.Hwithin <- as.matrix(listw %*% L.Hwithin)
	Hwithin <- cbind(Hwithin, L.Hwithin, L2.Hwithin)

	L.Hbetween <- as.matrix(listwnn %*% Hbetween)
	L2.Hbetween <- as.matrix(listwnn %*% L.Hbetween)
	Hbetween <- cbind(Hbetween, L.Hbetween, L2.Hbetween)
	
}

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

Hwithin<-cbind(Hwithin, WXwithin, WWXwithin)


transendog<-panel.transformations(endog,indic, type= "both")
endogbetween<-transendog[[2]]
endogwithin<-transendog[[1]]

# endogbetweennt<-matrix(,NT, ncol(endogbetween))
# for (i in 1:ncol(endogbetween)) endogbetweennt[,i]<-rep(endogbetween[,i], T)

endogwithin<-cbind(endogwithin, wywithin)
colnames(endogwithin) <- c(colnames(endog), "lambda")
    
resw<-spgm.tsls(as.matrix(ywithin), as.matrix(endogwithin), Xwithin, Hwithin )
sigma2v1<-resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - ncol(endogwithin)) 


Hbetween <- cbind(Hbetween, WXbetween, WWXbetween)
endogbetween <- cbind(endogbetween, as.matrix(wybetween))
colnames(endogbetween) <- c(colnames(endog), "lambda")
endogbetweennt<-matrix(,NT, ncol(endogbetween))
for (i in 1:ncol(endogbetween)) endogbetweennt[,i]<-rep(endogbetween[,i], T)


resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween),  sqrt(T)*as.matrix(endogbetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween))
sigma21<-resb$sse / resb$df


ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
# print(dim(endogwithin))
# print(dim(as.matrix(endogbetween)))
endogstar<-endogwithin/sqrt(sigma2v1) + as.matrix(endogbetweennt)/sqrt(as.numeric(sigma21))

# print(sigma2v1)
# print(sigma21)

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

A<-cbind(1,Xwithin[,-del],Xbetweennt[,-del], Hwithin, Hbetweennt)

res <- spgm.tsls(ystar, endogstar, xstar, Hinst = A, instr = TRUE)
# print(res$coefficients)

res$sigma1<- sigma21
res$sigma1<- sigma2v1


	}	
	
	}

res 

}
 


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ivplm.g2sls.R"
# # # # # g2sls

ivplm.g2sls <-function(Y,X,H = NULL,endog = NULL, lag=FALSE, listw, lag.instruments, T = T, N = N, NT = NT){

indic <- rep(1:N,T)
listwnn <- listw[1:N,1:N]
##transform y	
transy<-panel.transformations(Y,indic, type= "both")
ybetween<-transy[[2]]
ywithin<-transy[[1]]
ybetweennt<- rep(ybetween, T)	

##transform X	
transx<-panel.transformations(X,indic, type= "both")
Xbetween<-transx[[2]]
Xwithin<-transx[[1]]
colnames(Xwithin)<-colnames(X)
colnames(Xbetween)<-colnames(X)
Xbetweennt<-matrix(,NT, ncol(Xbetween))
for (i in 1:ncol(Xbetween)) Xbetweennt[,i]<-rep(Xbetween[,i],T)
del<- which(diag(var(Xwithin))==0)
colnames(Xbetweennt)<-colnames(X)

if(!lag){

##transform the instruments H
transH<-panel.transformations(H, indic, type= "both")
Hbetween<-transH[[2]]
Hwithin<-transH[[1]]

if(lag.instruments ) {
	
	L.Hwithin <- listw %*% Hwithin
	L2.Hwithin <- listw %*% L.Hwithin
	Hwithin <- cbind(Hwithin, as.matrix(L.Hwithin), as.matrix(L2.Hwithin))

	L.Hbetween <- listwnn %*% Hbetween
	L2.Hbetween <- listwnn %*% L.Hbetween
	Hbetween <- cbind(Hbetween, as.matrix(L.Hbetween), as.matrix(L2.Hbetween))
	
}

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

##transform the endogenous variables endog
transendog<-panel.transformations(endog, indic, type= "both")
endogbetween<-transendog[[2]]
endogwithin<-transendog[[1]]
endogbetweennt<-matrix(,NT, ncol(endogbetween))
for (i in 1:ncol(endogbetween)) endogbetweennt[,i] <- rep(endogbetween[,i], T)
colnames(endogbetweennt)<-colnames(endog)
colnames(endogwithin)<-colnames(endog)

#W2SLS
resw<-spgm.tsls(as.matrix(ywithin), endogwithin, Xwithin, Hwithin )

sigma2v1<-resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - ncol(endogwithin)) 

#B2SLS
resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(endogbetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )

sigma21<-resb$sse /  resb$df

ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
endogstar<-endogwithin/sqrt(sigma2v1) + endogbetweennt/sqrt(sigma21)


Hstar<-Hwithin/sqrt(sigma2v1) + Hbetweennt/sqrt(sigma21)

res<-spgm.tsls(ystar, endogstar, xstar, Hstar )
res$sigma1<-sigma21
res$sigmav<-sigma2v1

}

else{
       wy<-listw %*% Y
       wy <- as.matrix(wy)
     colnames(wy)<-"lambda"  
	  wywithin <- listw %*% ywithin
     wywithin <- as.matrix(wywithin)
     colnames(wywithin)<-"lambda"
  	  wybetween <- listwnn %*%  as.matrix(ybetween)
     colnames(wybetween) <- "lambda"

           WXwithin <- as.matrix(listw %*% Xwithin)
           WWXwithin <- as.matrix(listw %*% WXwithin)

            WXbetween <- as.matrix(listwnn %*% Xbetween)
            WWXbetween <- as.matrix(listwnn %*% WXbetween)
	
	if(is.null(endog)){

Hwithin<-cbind(WXwithin, WWXwithin)    
    
resw<-spgm.tsls(ywithin, wywithin, Xwithin, Hwithin)

sigma2v1<- resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - 1) 

        
Hbetween<-cbind(WXbetween, WWXbetween)        

resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(wybetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween) )
sigma21<-resb$sse /  resb$df


ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
endogstar<-wywithin/sqrt(sigma2v1) + rep(as.matrix(wybetween), T)/sqrt(as.numeric(sigma21))
endogstar<-as.matrix(endogstar)
colnames(endogstar)<-"lambda"

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

Hstar<-Hwithin/sqrt(sigma2v1) + Hbetweennt/sqrt(sigma21)

res <- spgm.tsls(ystar, endogstar, xstar, Hstar)

res$sigma1 <- sigma21
res$sigmav <- sigma2v1

}


else{

transH<-panel.transformations(H, indic, type= "both")
Hbetween<-transH[[2]]
Hwithin<-transH[[1]]

if(lag.instruments ) {
	
	L.Hwithin <- as.matrix(listw %*% Hwithin)
	L2.Hwithin <- as.matrix(listw %*% L.Hwithin)
	Hwithin <- cbind(Hwithin, L.Hwithin, L2.Hwithin)

	L.Hbetween <- as.matrix(listwnn %*% Hbetween)
	L2.Hbetween <- as.matrix(listwnn %*% L.Hbetween)
	Hbetween <- cbind(Hbetween, L.Hbetween, L2.Hbetween)
	
}


Hbetweennt<-matrix(, NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

Hwithin<-cbind(Hwithin, WXwithin, WWXwithin)


transendog<-panel.transformations(endog, indic, type= "both")
endogbetween<-transendog[[2]]
endogwithin<-transendog[[1]]

endogwithin<-cbind(endogwithin, wywithin)
    
resw<-spgm.tsls(as.matrix(ywithin), as.matrix(endogwithin), Xwithin, Hwithin )
sigma2v1<-resw$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin[,-del])) - ncol(endogwithin)) 


Hbetween<-cbind(Hbetween, as.matrix(WXbetween), as.matrix(WWXbetween))
endogbetween<-cbind(endogbetween, as.matrix(wybetween))
endogbetweennt<-matrix(,NT, ncol(endogbetween))
for (i in 1:ncol(endogbetween)) endogbetweennt[,i]<-rep(endogbetween[,i], T)

resb<-spgm.tsls(sqrt(T)*as.matrix(ybetween), sqrt(T)*as.matrix(endogbetween), sqrt(T)*Xbetween, sqrt(T)*as.matrix(Hbetween))
sigma21<-resb$sse / resb$df

ystar<-ywithin/sqrt(sigma2v1) + ybetweennt/sqrt(sigma21)
xstar<-Xwithin/sqrt(sigma2v1) + Xbetweennt/sqrt(sigma21)
endogstar<-endogwithin/sqrt(sigma2v1) + endogbetweennt/sqrt(sigma21)

Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

Hstar<- Hwithin/sqrt(sigma2v1) + Hbetweennt/sqrt(sigma21)

res <- spgm.tsls(ystar, endogstar, xstar, Hstar)

res$sigma1<- sigma21
res$sigma1<- sigma2v1
	}
}


res
}


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ivplm.w2sls.R"
###### within 2sls
ivplm.w2sls <- function(Y,X,H = NULL, endog = NULL, lag=FALSE, listw, lag.instruments,T,N,NT, twow = FALSE, listw2 = NULL){

indic <- rep(1:N,T)
##transform y and X	
ywithin <-panel.transformations(Y,indic, type= "within")
Xwithin <- panel.transformations(X, indic, type= "within")

colnames(Xwithin)<-colnames(X)
del <- which(diag(var(Xwithin)) == 0)
Xwithin <- Xwithin[,-del]
# print(Xwithin[1:5,])	


if(!lag){
##transform the instruments H
Hwithin <-panel.transformations(H, indic, type= "within")

if(lag.instruments) {
	
	L.Hwithin <- as.matrix(listw %*% Hwithin)
	L2.Hwithin <- as.matrix(listw %*% L.Hwithin)
	Hwithin <- cbind(Hwithin, as.matrix(L.Hwithin), as.matrix(L2.Hwithin))
	
}


##transform the endogenous variables endog
endogwithin <-panel.transformations(endog, indic, type= "within")
colnames(endogwithin)<-colnames(endog)

res<-spgm.tsls(as.matrix(ywithin), as.matrix(endogwithin), Xwithin, as.matrix(Hwithin))
varb<-res$var *res$df /((N * (T -1)) - ncol(as.matrix(Xwithin)) - ncol(endogwithin)) 
res$var<-varb
sigma2v1<- res$sse/ ((N * (T -1)) - ncol(as.matrix(Xwithin)) - ncol(endogwithin)) 
res$sigmav<- sigma2v1	
res$Hwithin <- Hwithin


	}
	
else{

   wywithin <- listw %*% as.matrix(ywithin)
   wywithin <- as.matrix(wywithin)
   colnames(wywithin)<-"lambda"

if(is.null(endog)){

            if(twow){
            	
	WXwithin <- listw %*%  Xwithin
    WWXwithin <- listw %*% WXwithin
	W2Xwithin <- listw2 %*%  Xwithin
    W2WXwithin <- listw2 %*% WXwithin
    W2WWXwithin <- listw2 %*% WWXwithin
            	
 	Hwithin <-cbind(as.matrix(WXwithin), as.matrix(WWXwithin), as.matrix(W2Xwithin), as.matrix(W2WXwithin), as.matrix(W2WWXwithin))            	
    
            }
else{            
	
	WXwithin <- listw %*%  Xwithin
    WWXwithin <- listw %*% WXwithin
 	Hwithin <-cbind(as.matrix(WXwithin), as.matrix(WWXwithin))
 	
 	}


res<-spgm.tsls(ywithin, wywithin, Xwithin, Hwithin)
varb<-res$var *res$df / ((N * (T -1)) - ncol(as.matrix(Xwithin)) - 1) 
res$var<-varb
sigma2v1<- res$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin)) - 1) 
res$sigmav <- sigma2v1
res$Hwithin <- Hwithin
		}
		
else{
			
			Hwithin <-panel.transformations(H, indic, type= "within")
			
if(lag.instruments ) {
	
	L.Hwithin <- listw %*% Hwithin
	L2.Hwithin <- listw %*% L.Hwithin

	if(twow){
		
		w2.Hwithin <- as.matrix(listw2 %*% Hwithin)
		w2w.Hwithin <- as.matrix(listw2 %*% L.Hwithin)
		w2ww.Hwithin <- as.matrix(listw2 %*% L2.Hwithin)
	Hwithin <- cbind(Hwithin, as.matrix(L.Hwithin), as.matrix(L2.Hwithin), w2.Hwithin, w2w.Hwithin, w2ww.Hwithin)		
	
	}
	
	else 	Hwithin <- cbind(Hwithin, as.matrix(L.Hwithin), as.matrix(L2.Hwithin))
}


            if(twow){
            	
	WXwithin <- listw %*%  Xwithin
    WWXwithin <- listw %*% WXwithin
	W2Xwithin <- listw2 %*%  Xwithin
    W2WXwithin <- listw2 %*% WXwithin
    W2WWXwithin <- listw2 %*% WWXwithin
            	
 	Hwithin <-cbind(Hwithin, as.matrix(WXwithin), as.matrix(WWXwithin), as.matrix(W2Xwithin), as.matrix(W2WXwithin), as.matrix(W2WWXwithin))            	
    
            }
else{            
	
	WXwithin <- listw %*%  Xwithin
    WWXwithin <- listw %*% WXwithin
 	Hwithin <-cbind(Hwithin, as.matrix(WXwithin), as.matrix(WWXwithin))
 	
 	}


endogwithin <- panel.transformations(endog, indic, type= "within")

endogwithin <-cbind(endogwithin, wywithin)
colnames(endogwithin)<-c(colnames(endog), "lambda")
# colnames(Xwithin)<-colnames(X)[-del]

res<-spgm.tsls(ywithin, endogwithin, Xwithin, Hwithin)

varb<-res$var *res$df / ((N * (T -1)) - ncol(as.matrix(Xwithin)) - ncol(endogwithin)) 
res$var<-varb
sigma2v1<- res$sse / ((N * (T -1)) - ncol(as.matrix(Xwithin)) - ncol(endogwithin)) 
res$sigmav <- sigma2v1
res$Hwithin <- Hwithin
	}		
	
	}	
res
}




#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ivsplm.R"
ivsplm <-function(formula,data=list(), index=NULL, endog = NULL, instruments= NULL, method = c("w2sls", "b2sls", "g2sls", "ec2sls"), lag = FALSE, listw = listw, effects = NULL, lag.instruments = FALSE){

# If the user do not make any choice in terms of method, when effects is Fixed the function calculates the w2sls. On the other hand, when effects is random the function calculates the ec2sls
if(length(method) !=1 && effects == "fixed") method <- "w2sls" 	
if(length(method) !=1 && effects == "random") method <- "ec2sls" 	
		
 if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }
  
  index <- data[,1]
  tindex <- data[,2]

  names(index)<-row.names(data)
  ind <-index[which(names(index)%in%row.names(data))]
  tind<-tindex[which(names(index)%in%row.names(data))]
   spord <- order(tind, ind)
   data <-  data[spord,]


  ## record call
  cl <- match.call()

  ## check
  if(dim(data)[[1]]!=length(index)) stop("Non conformable arguments")
  
    mt <- terms(formula, data = data)
    mf <- lm(formula, data, na.action = na.fail, method = "model.frame")

    y <- model.extract(mf, "response")
    x <- model.matrix(mt, mf)
 
  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)



  balanced<-N*T==NT
if(!balanced) stop("Estimation method unavailable for unbalanced panels")

# print(listw)
#### creating the block diagonal matrix
if(lag){
I_T <- Diagonal(T)
Ws <- kronecker(I_T, listw)
}
# else Ws <- NULL

if(!lag){
	
if(is.null(endog)) stop("No endogenous variables specified. Please use plm instead of splm")

else {
	endog <- as.matrix(lm(endog, data, na.action = na.fail, method = "model.frame"))

if(!is.null(listw)){
I_T <- Diagonal(T)
Ws <- kronecker(I_T, listw)
	
}	
	}

if(is.null(instruments)) stop("No instruments specified")

else instruments <- as.matrix(lm(instruments, data, na.action = na.fail, method = "model.frame"))

}


else{

if(!is.null(endog)){

endog <- as.matrix(lm(endog, data, na.action = na.fail, method = "model.frame"))

if(is.null(instruments)) stop("No instruments specified for the additional variable")

else instruments <- as.matrix(lm(instruments, data, na.action = na.fail, method = "model.frame"))	

		
	}
	else instruments = NULL
	}



switch(method, 
w2sls = {
	result <- ivplm.w2sls(Y = y, X = x, H = instruments, endog = endog, lag = lag, listw = Ws, lag.instruments = lag.instruments, T = T, N = N, NT = NT)
	},
b2sls = {
	result <- ivplm.b2sls(Y = y,X =x, H = instruments, endog = endog, lag = lag, listw = Ws, lag.instruments = lag.instruments, T = T, N = N, NT = NT)
	},
ec2sls = {
	result <- ivplm.ec2sls(Y = y,X =x, H = instruments, endog = endog, lag = lag, listw = Ws, lag.instruments = lag.instruments, T = T, N = N, NT = NT)
	},
g2sls = {
	result <-ivplm.g2sls(Y = y,X =x, H = instruments, endog = endog, lag = lag, listw = Ws, lag.instruments = lag.instruments, T = T, N = N, NT = NT )
	},
stop("...\nUnknown method\n"))


    result$zero.policy <- FALSE
    result$robust <- FALSE
    result$legacy <- FALSE
    result$listw_style <- NULL
    result$call <- match.call()


class(result) <- "stsls"
result
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/likelihoodsFE.R"
#### SAR PANEL
`conclikpan` <- function(lambda, env){
	
	e0e0 <- get("e0e0", envir = env)
	e1e1 <- get("e1e1", envir = env)
	e0e1 <- get("e0e1", envir = env)
	NT <- get("NT", envir = env)
	T <- get("T", envir = env)
	
	Nsig <- e0e0 - 2*lambda*e0e1 + lambda*lambda*e1e1
	sigma2 <- Nsig/NT
	
	ldet <-  do_ldet(lambda, env)

ret <- - (NT/2)*log(Nsig)  + T * ldet  


	  if (get("verbose", envir=env)) 
        cat("lambda:\t", lambda, "\tfunction value:\t", ret, 
            "\n")
	ret
}


splaglm<-function(env, zero.policy = zero.policy, interval = interval, con = con, llprof = llprof, tol.solve= tol.solve, Hess = Hess, method = method, LeeYu = LeeYu, effects = effects){

xt <- get("xt", envir = env)
yt <- get("yt", envir = env)
wyt <- get("wyt", envir = env)
con<-get("con", envir = env)
NT<-get("NT", envir = env)
T<-get("T", envir = env)
n <- NT/T
listw<-get("listw", envir = env)
inde<-get("inde", envir = env)
interval1 <- get("interval1", envir = env)

        XpX<-crossprod(xt)
		b0<-solve(XpX,crossprod(xt,yt)) ####y on X
		b1<-solve(XpX,crossprod(xt,wyt)) ####Wy on x
		e0<-yt - xt%*% b0
		e1<-wyt - xt%*% b1
		e0e0<-crossprod(e0)
		e1e1<-crossprod(e1)
		e0e1<-t(e1)%*%e0


assign("e0e0", e0e0, envir = env)		
assign("e1e1", e1e1, envir = env)		
assign("e0e1", e0e1, envir = env)		
		
 
opt <- optimize(conclikpan,  interval = interval1, maximum = TRUE, env = env, tol = con$tol.opt)
#opt <- nlminb(0.02138744, conclikpan,  lower = interval[1], upper= interval[2],  env = env)

        lambda <- opt$maximum
		
    if (isTRUE(all.equal(lambda, interval[1])) || isTRUE(all.equal(lambda,interval[2]))) 
        warning("lambda on interval bound - results should not be used")

        names(lambda) <- "lambda"
        LL <- opt$objective
        optres <- opt

	lm.lag <- lm((yt - lambda * wyt) ~ xt - 1)
	p <- lm.lag$rank
    r <- residuals(lm.lag)
    fit <- yt - r
    names(r) <- names(fit)
    SSE <- crossprod(residuals(lm.lag))
    s2 <- as.numeric(SSE)/NT

if(LeeYu && effects == "spfe") s2 <- (T/(T-1)) * as.numeric(s2)	
if(LeeYu && effects == "tpfe") s2 <- (n/(n-1)) * as.numeric(s2)	

	betas <- coefficients(lm.lag)
	 # betas <- b0 - lambda*b1
	names(betas) <- colnames(xt)
	coefs <- c(lambda, betas)


if(LeeYu && effects == "sptpfe"){
	   
	    tr <- function(A) sum(diag(A))
        W <-listw2dgCMatrix(listw, zero.policy = zero.policy)
        A <- solve(sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1) - lambda * W)
        WA <- W %*% A
		lag <- function(q) trash<-unlist(tapply(q,inde,function(TT) as.matrix(WA %*% TT), simplify=TRUE))	  
		lag2 <- function(q) trash<-unlist(tapply(q,inde,function(TT) as.matrix(t(WA)%*%TT), simplify=TRUE))
		WAxt <- apply(as.matrix(xt),2,lag)
        WAWAxt<-apply(WAxt,2,lag2)
        xtWAWAxt <- crossprod(xt,WAWAxt)
        xtWAxt <- crossprod(xt,WAxt)
        xtxt <- crossprod(xt) 
	    one  <- T*(tr(WA %*% WA) + tr(t(WA) %*% WA))	    
        two <- 1/as.numeric(s2) * t(betas) %*% xtWAWAxt  %*% betas        
		V <- one + two
		zero <- rbind(rep(0, length(betas)))
        col1 <- rbind(NT/(2 * (s2^2)), T*tr(WA)/s2, t(zero))
        three <- (1/as.numeric(s2)) * xtWAxt %*% betas
        col2 <- rbind(T*tr(WA)/s2, V, three )
        col3 <- rbind(zero, t(three), 1/as.numeric(s2)* xtxt)
        asyvar <- cbind(col1, col2, col3)
        asyv <- solve(asyvar, tol = con$tol.solve)
		rownames(asyv) <- colnames(asyv) <- c("sigma","lambda", colnames(xt))

		init <- c((T/(T+1)), rep(1,p+1))	

		a3 <- rep(0,p)
		a2 <- 1/(1 - lambda)
		a1 <- 1/(2*s2)
		a <- c(a1,a2,a3)
		Bhat <- - (asyv/n) %*% a


		coefs1 <- c(s2,  lambda, betas)
		Theta2 <- init * coefs1 + Bhat
 		betas <- as.numeric(Theta2[(3:(2+p))])
 		names(betas) <- colnames(xt)  
 		lambda <-Theta2[2] 
        names(lambda) <- "lambda"
 		s2 <-  Theta2[1]
	    coefs <- c(lambda, betas)

	
}	

### add numerical hessian
if(Hess){
	
        fd <- fdHess(coefs, f_sarpanel_hess, env, LeeYu = LeeYu, effects = effects)
        mat <- fd$Hessian
		fdHess<- solve(-(mat), tol.solve = tol.solve)
        rownames(fdHess) <- colnames(fdHess) <- c("lambda", colnames(xt))
        
        lambda.se <- fdHess[1, 1]
        sig.se <- NULL
        asyvar1 <- vcov(lm.lag)
         rest.se<- NULL   
            
}

else{

        tr <- function(A) sum(diag(A))
        W <-listw2dgCMatrix(listw, zero.policy = zero.policy)
        A <- solve(sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1) - lambda * W)
        WA <- W %*% A
		lag <- function(q) trash<-unlist(tapply(q,inde,function(TT) as.matrix(WA %*% TT), simplify=TRUE))	  
		lag2 <- function(q) trash<-unlist(tapply(q,inde,function(TT) as.matrix(t(WA)%*%TT), simplify=TRUE))
		WAxt <- apply(as.matrix(xt),2,lag)
        WAWAxt<-apply(WAxt,2,lag2)
        xtWAWAxt <- crossprod(xt,WAWAxt)
        xtWAxt <- crossprod(xt,WAxt)
        xtxt <- crossprod(xt) 

if(LeeYu && effects == "spfe"){
	T <- T- 1
	NT <- n*T
}	

if(LeeYu && effects == "tpfe"){
	n <- n-1
	NT <- n*T
}	
        
 if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		
        one  <- T*(tr(WA %*% WA) + tr(t(WA) %*% WA))
        two <- 1/as.numeric(s2) * t(betas) %*% xtWAWAxt  %*% betas
		V <- one + two
		zero <- rbind(rep(0, length(betas)))
        col1 <- rbind(NT/(2 * (s2^2)), T*tr(WA)/s2, t(zero))
        three <- (1/as.numeric(s2)) * xtWAxt %*% betas
        col2 <- rbind(T*tr(WA)/s2, V, three )
        col3 <- rbind(zero, t(three), 1/as.numeric(s2)* xtxt)
        asyvar <- cbind(col1, col2, col3)
        asyva <- solve(asyvar, tol = con$tol.solve)
        rownames(asyva) <- colnames(asyva) <- c("sigma","lambda", colnames(xt))
        
        lambda.se <- asyva[2, 2]        
        rest.se <- sqrt(diag(asyva))[-c(1:2)]
        sig.se <- sqrt(asyva[1, 1]) 
        asyv <- asyva[-1,-1]      
        asyvar1 <- as.matrix(asyva[-c(1,2),-c(1,2)])
        rownames(asyvar1) <- colnames(asyvar1) <- colnames(xt)


}

if(Hess) asyv <- NULL        
else asyv <- asyv


 
    	return<-list(coeff = betas, lambda = lambda, s2 = s2, rest.se = rest.se, lambda.se = lambda.se, sig.se = sig.se, asyvar1 = asyvar1,  residuals = r, asyv = asyv)
} 



f_sarpanel_hess <- function (coefs, env, effects = effects, LeeYu = LeeYu) 
{
	
	T<-get("T", envir = env)
	NT<-get("NT", envir = env)
    n <- NT/T
    
if(LeeYu && effects == "spfe"){

	T <- T- 1
	NT <- n*T
}	

if(LeeYu && effects == "tpfe"){
	n <- n-1
	NT <- n*T
}	


if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		

    lambda <- coefs[1]
    beta <- coefs[-1]
    SSE <- sar_hess_sse_panel(lambda, beta, env)
    s2 <- SSE /n
    
    ldet <- do_ldet(lambda, env, which = 1)
    ret <- (T * ldet  - ((n*T/2) * log(2 * pi)) - (n*T/2) * log(s2) - 
        (1/(2 * s2)) * SSE)
    if (get("verbose", envir = env)) 
        cat("lambda:", lambda, " function:", ret, " Jacobian:", ldet," SSE:", SSE, "\n")
    ret
}

sar_hess_sse_panel <- function (lambda, beta, env) 
{
    yl <- get("yt", envir = env) - lambda * get("wyt", envir = env) 
    res <- yl - (get("xt", envir = env) %*% beta)
    SSE <- c(crossprod(res))
    SSE
}


####### ERROR MODEL 
sarpanelerror<-function (rho, env=env) 
{
	yt<- get("yt", envir = env)
	xt<- get("xt", envir = env)
	wyt<- get("wyt", envir = env)
	wxt<- get("wxt", envir = env)
	wy<- get("wy", envir = env)
	wx<- get("wx", envir = env)

	listw<- get("listw", envir = env)
	NT<- get("NT", envir = env)
	inde<- get("inde", envir = env)
	T<- get("T", envir = env)
	
    yco <- yt - rho * wyt
    xco <- xt - rho * wxt
    bb<- solve(crossprod(xco),crossprod(xco, yco) )

    ehat<- yco - xco %*% bb
    SSE <- crossprod(ehat)
  ldet <- do_ldet(rho, env)

    ret <- T*ldet - (NT/2) * log(SSE) 

if (get("verbose", envir = env)) 
        cat("rho:", rho, " function:", ret, " Jacobian:", ldet, " SSE:", SSE, "\n")
 ret
}





sperrorlm <- function(env, zero.policy = zero.policy, interval = interval, con = con, llprof = llprof, tol.solve= tol.solve, Hess = Hess, LeeYu = LeeYu, effects = effects){

xt <- get("xt", envir = env)
yt <- get("yt", envir = env)
wyt <- get("wyt", envir = env)
wxt<-get("wxt", envir = env)

wy <- get("wy", envir = env)
wx<-get("wx", envir = env)

con<-get("con", envir = env)
NT<-get("NT", envir = env)
T<-get("T", envir = env)
n <- NT/T
listw<-get("listw", envir = env)
inde<-get("inde", envir = env)
interval <- get("interval1", envir = env)

opt <- optimize(sarpanelerror, interval = interval, maximum = TRUE, env = env, tol = con$tol.opt)


#opt <- nlminb(0.5,sarpanelerror,lower = interval[1], upper= interval[2], env = env)
#print(opt)

        rho <- opt$maximum
        names(rho) <- "rho"
        LL <- opt$objective

    if (isTRUE(all.equal(rho, interval[1])) || isTRUE(all.equal(rho,interval[2]))) 
        warning("rho on interval bound - results should not be used")

    lm.target <- lm(I(yt - rho * wyt) ~ I(xt - rho * wxt) - 
        1)
    r <- as.vector(residuals(lm.target))
    p <- lm.target$rank
    SSE <- crossprod(residuals(lm.target))
    s2 <- as.numeric(SSE)/NT

if(LeeYu && effects == "spfe") s2 <- (T/(T-1)) * as.numeric(s2)	
if(LeeYu && effects == "tpfe") s2 <- (n/(n-1)) * as.numeric(s2)	

    rest.se <- (summary(lm.target)$coefficients[, 2]) * sqrt((NT - p)/NT)     
    betas <- coefficients(lm.target)
    names(betas) <- colnames(xt)  
     coefs <- c(rho, betas) 

if(LeeYu && effects == "sptpfe"){
	    
	    tr <- function(A) sum(diag(A))
        W <- listw2dgCMatrix(listw, zero.policy = zero.policy)
        A <- solve(sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - rho * W)
        WA <- W %*% A
        asyvar <- matrix(0, nrow = 2 + p, ncol = 2 + p)
        asyvar[1, 1] <- NT/(2 * (s2^2))
        asyvar[2, 1] <- asyvar[1, 2] <- T*tr(WA)/s2
        asyvar[2, 2] <- T*(tr(WA %*% WA) + tr(t(WA) %*% WA))
        asyvar[3:(p + 2), 3:(p + 2)] <- 1/as.numeric(s2) * (t(xt - rho *wxt) %*% (xt - rho * wxt)) 
        asyv <- solve(asyvar, tol = con$tol.solve)
        rownames(asyv) <- colnames(asyv) <- c("sigma","rho", colnames(xt))

        s2.se <- sqrt(asyv[1, 1])
        rho.se <- asyv[2, 2]
        asyvar1 <- asyv[-c(1,2),-c(1,2)]
		init <- c((T/(T+1)), rep(1,p+1))	

		a3 <- rep(0,p)
		a2 <- 1/(1 - rho)
		a1 <- 1/(2*s2)
		a <- c(a1,a2,a3)
		Bhat <- - (asyv/n) %*% a


		coefs1 <- c(s2, rho, betas)
		Theta2 <- init * coefs1 + Bhat
 		betas <- as.numeric(Theta2[(3:(2+p))])
 		names(betas) <- colnames(xt)  
 		rho <-Theta2[2] 
        names(rho) <- "rho"
 		s2 <-  Theta2[1]
	    coefs <- c(rho, betas)

	
	
	
}

if(Hess){
	
	    fd <- fdHess(coefs, sarpanelerror_hess, env, LeeYu = LeeYu, effects = effects)
        mat <- fd$Hessian
		fdHess<- solve(-(mat), tol.solve = tol.solve)
        rownames(fdHess) <- colnames(fdHess) <- c("rho",colnames(xt))

            rho.se <- fdHess[1, 1]
            s2.se <- NULL
            asyvar1 <- vcov(lm.target)
}
else{
    
        tr <- function(A) sum(diag(A))
        W <- listw2dgCMatrix(listw, zero.policy = zero.policy)
        A <- solve(sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - rho * W)
        WA <- W %*% A

if(LeeYu && effects == "spfe"){

	T <- T- 1
	NT <- n*T

}	

if(LeeYu && effects == "tpfe"){

	n <- n-1
	NT <- n*T

}	

 if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		

        asyvar <- matrix(0, nrow = 2 + p, ncol = 2 + p)
        asyvar[1, 1] <- NT/(2 * (s2^2))
        asyvar[2, 1] <- asyvar[1, 2] <- T*tr(WA)/s2
        asyvar[2, 2] <- T*(tr(WA %*% WA) + tr(t(WA) %*% WA))
        asyvar[3:(p + 2), 3:(p + 2)] <- 1/as.numeric(s2) * (t(xt - rho *wxt) %*% (xt - rho * wxt)) 
        asyva <- solve(asyvar, tol = con$tol.solve)
        rownames(asyva) <- colnames(asyva) <- c("sigma","rho", colnames(xt))
        s2.se <- sqrt(asyva[1, 1])
        rho.se <- asyva[2, 2]
        asyvar1 <- asyva[-c(1,2),-c(1,2)]
        asyv <- asyva[-1,-1]
        rownames(asyvar1) <- colnames(asyvar1) <- colnames(xt)

        

}

if(Hess) asyv <- NULL        
else asyv <- asyv


	return<-list(coeff=betas, rho = rho, s2 = s2, rest.se = rest.se, rho.se = rho.se, s2.se = s2.se, asyvar1=asyvar1, residuals = r, asyv = asyv)
}



sarpanelerror_hess<-function (coef, env=env, LeeYu = LeeYu, effects = effects) 
{
	yt<- get("yt", envir = env)
	xt<- get("xt", envir = env)
	wyt<- get("wyt", envir = env)
	wxt<- get("wxt", envir = env)
	wy<- get("wy", envir = env)
	wx<- get("wx", envir = env)

	listw<- get("listw", envir = env)
	NT<- get("NT", envir = env)
	inde<- get("inde", envir = env)
	T<- get("T", envir = env)
	n <- NT/T

if(LeeYu && effects == "spfe"){
	T <- T- 1
	NT <- n*T
}	

if(LeeYu && effects == "tpfe"){
	n <- n-1
	NT <- n*T
}	

 if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		

	rho <- coef[1]
	bb <- coef[-1]
	 
     yco <- yt - rho * wyt
     xco <- xt - rho * wxt

     ehat<- yco - xco %*% bb
    SSE <- crossprod(ehat)

  ldet <- do_ldet(rho, env)

    ret <- T*ldet - (NT/2) * log(SSE) 

if (get("verbose", envir = env)) 
        cat("rho:", rho, " function:", ret, " Jacobian:", ldet, " SSE:", SSE, "\n")
 ret
}


###SARAR MODEL

sacsarpanel<-function (coefs, env){

	lambda <- coefs[1]
    rho <- coefs[2]
  	 T<-get("T", envir = env)
    n <- get("n", envir = env)

    SSE <- sacsarpanel_sse(coefs, env)
    s2 <- SSE/n
    ldet1 <- do_ldet(lambda, env, which = 1)
    ldet2 <- do_ldet(rho, env, which = 2)

ret <- (T * ldet1 + T * ldet2 - (((n*T)/2) * (log(2 * pi)+1)) - (n*T/2) * log(s2))
                        # - (1/(2 * (s2))) * SSE)
if(get("verbose", envir = env)) cat("lambda:", lambda, " rho:", rho, " function:", 
             ret, " Jacobian1:", ldet1, " Jacobian2:", ldet2, 
             " SSE:", SSE, "\n")
-ret
}


sacsarpanel_sse <- function (coefs, env) 
{
    lambda <- coefs[1]
    rho <- coefs[2]
    yl <- get("yt", envir = env) - lambda * get("wyt", envir = env) - 
        rho * get("w2yt", envir = env) + rho * lambda * get("w2wyt", 
        envir = env)
    xl <- get("xt", envir = env) - rho * get("wxt", envir = env)
    xl.q <- qr.Q(qr(xl, LAPACK = get("LAPACK", envir = env)))
    xl.q.yl <- crossprod(xl.q, yl)
    SSE <- crossprod(yl) - crossprod(xl.q.yl)
    SSE
}


spsararlm<-function(env, zero.policy = zero.policy, con = con, llprof = llprof, tol.solve= tol.solve, Hess = Hess, method = method, LeeYu = LeeYu, effects = effects){

xt <- get("xt", envir = env)
yt <- get("yt", envir = env)
wyt <- get("wyt", envir = env)
w2yt <- get("w2yt", envir = env)
w2wyt <- get("w2wyt", envir = env)
wxt<-get("wxt", envir = env)

wy <- get("wy", envir = env)
wx<-get("wx", envir = env)
	
NT<-get("NT", envir = env)
T<-get("T", envir = env)
n<-get("n", envir = env)

listw<-get("listw", envir = env)
listw2<-get("listw2", envir = env)
inde<-get("inde", envir = env)
interval1 <- get("interval1", envir = env)
interval2 <- get("interval2", envir = env)
	
    pars <- con$pars
    lower <- c(interval1[1], interval2[1])
    upper <- c(interval1[2], interval2[2])

    if (!is.null(llprof)) {
        llrho <- NULL
        lllambda <- NULL
        if (length(llprof) == 1L) {
            llrho <- seq(lower[2], upper[2], length.out = llprof)
            lllambda <- seq(lower[1], upper[1], length.out = llprof)
            llprof <- as.matrix(expand.grid(lllambda, llrho))
        }
        ll_prof <- numeric(nrow(llprof))
        for (i in 1:nrow(llprof)) ll_prof[i] <- sacsarpanel(llprof[i, 
            ], env = env)
        # nm <- paste(method, "profile", sep = "_")
        # timings[[nm]] <- proc.time() - .ptime_start
        # .ptime_start <- proc.time()
    }
    if (is.null(pars)) {
        if (con$npars == 4L) {
            xseq <- c(lower[1], 0, upper[1], upper[1]) * 0.8
            yseq <- c(upper[2], 0, upper[2], lower[2]) * 0.8
            mpars <- cbind(xseq, yseq)
        }
        else {
            xseq <- seq(lower[1], upper[1], (upper[1] - lower[1])/2) * 
                0.8
            yseq <- seq(lower[2], upper[2], (upper[2] - lower[2])/2) * 
                0.8
            mpars <- as.matrix(expand.grid(xseq, yseq))
        }
    }
    else {
        mxs <- NULL
    }
    if (con$opt_method == "nlminb") {
        if (is.null(pars)) {
            mxs <- apply(mpars, 1, function(pp) -nlminb(pp, sacsarpanel, 
                env = env, control = con$opt_control, lower = lower, 
                upper = upper)$objective)
            pars <- mpars[which.max(mxs), ]
            optres <- nlminb(pars, sacsarpanel, env = env, control = con$opt_control, 
                lower = lower, upper = upper)
        }
        else {
            optres <- nlminb(pars, sacsarpanel, env = env, control = con$opt_control, 
                lower = lower, upper = upper)
        }
    }
    else if (con$opt_method == "L-BFGS-B") {
        if (is.null(pars)) {
            mxs <- apply(mpars, 1, function(pp) -optim(pars, 
                sacsarpanel, env = env, method = "L-BFGS-B", control = con$opt_control, 
                lower = lower, upper = upper)$objective)
            pars <- mpars[which.max(mxs), ]
            optres <- optim(pars, sacsarpanel, env = env, method = "L-BFGS-B", 
                control = con$opt_control, lower = lower, upper = upper)
        }
        else {
            optres <- optim(pars, sacsarpanel, env = env, method = "L-BFGS-B", 
                control = con$opt_control, lower = lower, upper = upper)
        }
    }
    else {
        if (is.null(pars)) {
            mxs <- apply(mpars, 1, function(pp) -optim(pars, 
                sacsarpanel, env = env, method = con$opt_method, 
                control = con$opt_control)$objective)
            pars <- mpars[which.max(mxs), ]
            optres <- optim(pars, sacsarpanel, env = env, method = con$opt_method, 
                control = con$opt_control)
        }
        else {
            optres <- optim(pars, sacsarpanel, env = env, method = con$opt_method, 
                control = con$opt_control)
        }
    }
    
    LL <- -optres$objective
    if (optres$convergence != 0) 
        warning(paste("convergence failure:", optres$message))
	
	# print(optres)
    rho <- optres$par[2]
    names(rho) <- "rho"
    lambda <- optres$par[1]
    names(lambda) <- "lambda"


    
    lm.target <- lm(I(yt - lambda * wyt - rho * w2yt + rho * lambda * 
        w2wyt) ~ I(xt - rho * wxt) - 1)

    r <- as.vector(residuals(lm.target))
    fit <- as.vector(yt - r)
    p <- lm.target$rank
    SSE <- crossprod(residuals(lm.target))
    s2 <- as.numeric(SSE)/NT

if(LeeYu && effects == "spfe") s2 <- (T/(T-1)) * as.numeric(s2)	
if(LeeYu && effects == "tpfe") s2 <- (n/(n-1)) * as.numeric(s2)	

    betas <- coefficients(lm.target)
    names(betas) <- colnames(xt)  
	 coefs <- c(lambda, rho, betas)

if(LeeYu && effects == "sptpfe"){
	    
	    tr <- function(A) sum(diag(A))
        W1 <- listw2dgCMatrix(listw, zero.policy = zero.policy)
        W2 <- listw2dgCMatrix(listw2, zero.policy = zero.policy)
        Sl <- sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - lambda * W1
        Rr <- sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - rho * W2
        Slinv <- solve(Sl)
        Rrinv <- solve(Rr)
        Gmat <- W1 %*% Slinv
        Hmat <- W2 %*% Rrinv        
        It <- sparseMatrix(i=1:T, j=1:T, x=1)         
        Jn <- Diagonal(n) - (1/n) * outer(rep(1,n),rep(1,n))


# Equation 53 Lee and Yu         
        Wdot <- Rr %*% W1  %*% Rrinv
        Gdot <- Rr %*% Gmat  %*% Rrinv
        GS <- t(Gdot) + Gdot
        HS <- t(Hmat) + Hmat
        Rrbig <- kronecker(It,Rr)
        RriB  <- kronecker(It,Rrinv) 
        GdotB<-  kronecker(It,Gdot)
        WdotB<-  kronecker(It,Wdot)
        JnB <- kronecker(It,Jn)
        Xdot <-  Rrbig %*% xt  
        JXdot <- JnB %*% Xdot
        GdXdb <- GdotB %*% Xdot %*% betas
        JGdXdb <- JnB %*% GdotB %*% Xdot %*% betas
        
	    fp   <- (1/s2) * crossprod(GdXdb, JGdXdb)
        lala <- fp + (T * tr(GS %*% Jn %*% Gdot))
        laro <- T * tr(HS %*% Jn %*% Gdot) 
        lasi <- (1/s2) * T * tr(Gdot) 
        roro <- T * tr(HS %*% Hmat)
        rosi <- (1/s2) * T * tr(Hmat)
        sisi <- NT/(2*s2*s2)
        bebe <- (1/s2) * crossprod(Xdot, JXdot)       
        bela <- (1/s2) * crossprod(GdXdb, JXdot)
        
        asyvar <- matrix(0, nrow = 3 + p, ncol = 3 + p)
        asyvar[1:p, 1:p] <- as.matrix(bebe) 
        asyvar[p+1, 1:p] <- asyvar[1:p, p+1] <- as.numeric(bela)
        asyvar[p+2, 1:p] <- asyvar[1:p, p+2] <- 0
        asyvar[p+3, 1:p] <- asyvar[1:p, p+3] <- 0
        asyvar[p+2, p+1] <- asyvar[p+1, p+2] <- as.numeric(laro)
        asyvar[p+3, p+1] <- asyvar[p+1, p+3] <- as.numeric(lasi)
        asyvar[p+3, p+2] <- asyvar[p+2, p+3] <- as.numeric(rosi)        
        asyvar[1+p, 1+p] <- as.matrix(lala)
        asyvar[2+p, 2+p] <- as.matrix(roro)
        asyvar[3+p, 3+p] <- as.matrix(sisi)
        asyv <- solve(asyvar, tol = con$tol.solve)

		a1 <- rep(0,p)
		a2 <- as.numeric((1/n) * rep(1,n) %*% Gdot %*% rep(1,n))
		a3 <- as.numeric((1/n) * rep(1,n) %*% Hmat %*% rep(1,n))
		a4 <- as.numeric(1/(2*s2))
		a <- c(a1,a2,a3,a4)
		Bhat <- - asyv %*% a
		At <- matrix(0, nrow = 3 + p, ncol = 3 + p)
		At[(1:(p+2)), (1:(p+2))]<- diag((p+2))
		At[(1:(p+2)), 3+p] <- rep(0,p+2)
		At[3+p,(1:(p+2))] <- rep(0,p+2)
		At[3+p, 3+p] <- T/(T-1)
		coefs1 <- c(betas, lambda, rho, s2) 
		Theta1 <- coefs1 - (Bhat/n)
		Theta2 <- At %*% Theta1
 		betas <- Theta2[1:p]
 		names(betas) <- colnames(xt)  
 		lambda <-Theta2[p+1] 
 		rho <- Theta2[p+2]
 		names(rho) <- "rho"
        names(lambda) <- "lambda"
 		s2 <-  Theta2[p+3]
	    coefs <- c(lambda, rho, betas)
	
}


###Add the vc matrix exact
if(Hess){    

# if(LeeYu && effects == "sptpfe") stop("Numerical Hessian should not be calculated when 'LeeYu = TRUE' and effects are 'twoways' ")
	    
        fd <- fdHess(coefs, f_sacpanel_hess, env, LeeYu = LeeYu, effects = effects)
        mat <- fd$Hessian
		  fdHess<- solve(-(mat), tol.solve = tol.solve)
        rownames(fdHess) <- colnames(fdHess) <- c("lambda", "rho",colnames(xt))
            
            rho.se <- fdHess[2,2]
            lambda.se <- fdHess[1,1]
            asyvar1 <- vcov(lm.target)
            s2.se <- NULL
            }
            
            else{
            	
   
        tr <- function(A) sum(diag(A))
        W1 <- listw2dgCMatrix(listw, zero.policy = zero.policy)
        W2 <- listw2dgCMatrix(listw2, zero.policy = zero.policy)
        Sl <- sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - lambda * W1
        Rr <- sparseMatrix(i=1:(NT/T), j=1:(NT/T), x=1)  - rho * W2
        Slinv <- solve(Sl)
        Rrinv <- solve(Rr)
        Gmat <- W1 %*% Slinv
        Hmat <- W2 %*% Rrinv        
        It <- sparseMatrix(i=1:T, j=1:T, x=1)         
        

# Equation 39 Lee and Yu         
        Wdot <- Rr %*% W1  %*% Rrinv
        Gdot <- Rr %*% Gmat  %*% Rrinv
        GS <- t(Gdot) + Gdot
        HS <- t(Hmat) + Hmat
        Rrbig <- kronecker(It,Rr)
        RriB  <- kronecker(It,Rrinv) 
        GdotB<-  kronecker(It,Gdot)
        WdotB<-  kronecker(It,Wdot)
        Xdot <-  Rrbig %*% xt  
        GdXdb <- GdotB %*% Xdot %*% betas
   
        
if(LeeYu && effects == "spfe"){
	T <- T- 1
	NT <- n*T
}	

if(LeeYu && effects == "tpfe"){
	n <- n-1
	NT <- n*T
}	

if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		
        fp   <- (1/s2) *crossprod(GdXdb)
        lala <- fp + (T * tr(GS %*% Gdot))
        laro <- T * tr(HS %*% Gdot) 
        lasi <- (1/s2) * T * tr(Gdot) 
        roro <- T * tr(HS %*% Hmat)
        rosi <- (1/s2) * T * tr(Hmat)
        sisi <- NT/(2*s2*s2)
        bebe <- (1/s2) * crossprod(Xdot)       
        bela <- (1/s2) * crossprod(GdXdb, Xdot)
        
        asyvar <- matrix(0, nrow = 3 + p, ncol = 3 + p)
        asyvar[1:p, 1:p] <- as.matrix(bebe) 
        asyvar[p+1, 1:p] <- asyvar[1:p, p+1] <- as.numeric(bela)
        asyvar[p+2, 1:p] <- asyvar[1:p, p+2] <- 0
        asyvar[p+3, 1:p] <- asyvar[1:p, p+3] <- 0
        asyvar[p+2, p+1] <- asyvar[p+1, p+2] <- as.numeric(laro)
        asyvar[p+3, p+1] <- asyvar[p+1, p+3] <- as.numeric(lasi)
        asyvar[p+3, p+2] <- asyvar[p+2, p+3] <- as.numeric(rosi)        
        asyvar[1+p, 1+p] <- as.matrix(lala)
        asyvar[2+p, 2+p] <- as.matrix(roro)
        asyvar[3+p, 3+p] <- as.matrix(sisi)
        asyva <- solve(asyvar, tol = con$tol.solve)
        rownames(asyva) <- colnames(asyva) <- c(colnames(xt), "lambda", "rho", "sigma")

        s2.se <- asyva[3+p, 3+p]
        rho.se <- asyva[2+p, 2+p]
        lambda.se <- asyva[1+p, 1+p]
        rest.se <- sqrt(diag(asyva))[-((p+1):(p+3))]
        asyvar1 <- asyva[-((p+1):(p+3)),-((p+1):(p+3))]
        asyv <- asyva[-(p+3),-(p+3)]


            	}

if(Hess) asyv <- NULL        
else asyv <- asyv
        

return<-list(coeff = betas, lambda = lambda, rho = rho, s2 = s2, asyvar1 = asyvar1, lambda.se = lambda.se, rho.se = rho.se, s2.se = s2.se, residuals = r, asyv = asyv)	
	}

f_sacpanel_hess <- function (coefs, env, LeeYu = LeeYu, effects = effects) 
{
	T<-get("T", envir = env)
	NT<-get("NT", envir = env)
	n<-get("n", envir = env)

if(LeeYu && effects == "spfe"){
	T <- T- 1
	NT <- n*T
}	

if(LeeYu && effects == "tpfe"){
	n <- n-1
	NT <- n*T
}	

if(LeeYu && effects == "sptpfe"){
	n <- n-1
	T <- T-1
	NT <- n*T
}		

    lambda <- coefs[1] 
    rho <- coefs[2]
    beta <- coefs[-(1:2)]
      SSE <- sar_sac_hess_sse_panel(lambda, rho, beta, env)
    # SSE <- sar_sac_hess_sse_panel(lambda, rho, beta, env)
    n <- NT/T
    # SSE<- s2 *n
     s2<- SSE / n
    ldet1 <- do_ldet(lambda, env, which = 1)
    ldet2 <- do_ldet(rho, env, which = 2)
   
#ret <- (T * ldet1 + T * ldet2 - (((n*T)/2) * (log(2 * pi))) - (n*T/2) * log(s2))
                        # - (1/(2 * (s2))) * SSE)
ret <- (T * ldet1 + T * ldet2 - ((n*T/2) * log(2 * pi)) - (n*T/2) * log(s2) - 
        (1/(2 * s2)) * SSE)


    if (get("verbose", envir = env)) cat("rho:", rho, "lambda:", lambda, " function:", ret, 
            " Jacobian1:", ldet1, " Jacobian2:", ldet2, " SSE:", 
            SSE, "\n")
    ret
}

sar_sac_hess_sse_panel <- function (lambda, rho,  beta, env) 
{
    yl <- get("yt", envir = env) - lambda * get("wyt", envir = env) - 
        rho * get("w2yt", envir = env) + rho * lambda * get("w2wyt", 
         envir = env)
         
    xl <- get("xt", envir = env) - rho * get("wxt", envir = env)
    res <- yl - (xl %*% beta)
    SSE <- c(crossprod(res))
    SSE
}




#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/listw2dgCMatrix.R"
listw2dgCMatrix<-function (listw, zero.policy=NULL) 
{
    if (!inherits(listw, "listw")) 
        stop("not a listw object")
    if (is.null(zero.policy))
        zero.policy <- get.ZeroPolicyOption()
    stopifnot(is.logical(zero.policy))
    n <- length(listw$neighbours)
    cardw <- card(listw$neighbours)
    p0 <- as.integer(c(0, cumsum(cardw)))
    scard <- sum(cardw)
    t<-unlist(listw$neighbours)
    if (zero.policy) t <- t[t > 0]
    t<-t-1
    res <- new("dgCMatrix", i = as.integer(t), p = p0,  Dim = as.integer(c(n,n)), x = unlist(listw$weights))
    res<-t(res)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/lrtest.splm.R"
lrtest.splm <- function(x, y, ...) {
    ## correspondence with component names
    compnames <- c("RE", "AR(1)", "SEM", "SAR")
    compnames.long <- c("random effects", "AR(1) errors",
                        "spatial errors", "spatial lag")
    names(compnames) <- c("phi", "rho", "lambda", "psi")

    ## first: check same betas!
    if(!identical(names(x$coef), names(y$coef))) {
        stop("Models estimated on different regressors")
    }
    ## ...and Nobs
    if(!identical(length(x$residuals), length(y$residuals))) {
        stop("Models estimated on different number of obs.")
    }

    ## build error and ev. SAR components vector
    ecompsx <- c(names(x$errcomp), names(x$arcoef))
    ecompsy <- c(names(y$errcomp), names(y$arcoef))

    ## check that models be different
    if(identical(ecompsx, ecompsy)) stop("The model is the same")

    ## which model is bigger?
    if(length(ecompsx)>=length(ecompsy)) {
        m1 <- x
        m0 <- y
        ecomps1 <- ecompsx
        ecomps0 <- ecompsy
    } else {
        m1 <- y
        m0 <- x
        ecomps1 <- ecompsy
        ecomps0 <- ecompsx
    }

    ## check if nested
    if(!all(ecompsx %in%ecompsy) & !all(ecompsy %in% ecompsx)) {
        stop("Models are not nested")
    }

    ll1 <- m1$logLik
    ll0 <- m0$logLik

    testedparms <- ecomps1[-which(ecomps1 %in% ecomps0)]

    LRstat <- 2*(ll1-ll0)
    df <- abs(length(ecompsx) - length(ecompsy))
    names(df) <- "df"
    pLR <- pchisq(LRstat, df = df, lower.tail=FALSE)

    names(LRstat) <- "LR test"
    RVAL <- list(statistic = LRstat, parameter = df,
                 method = paste("Likelihood ratio for exclusion of",
                 paste(compnames[testedparms], collapse = ", "), "\n\n",
                 "from panel model with ",
                 paste(compnames[ecomps1], collapse = ", ")),
                 p.value = pLR, data.name = "dname here (see bgtest)")
    class(RVAL) <- "htest"
    return(RVAL)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/nonexportedSpdepFuns.R"
## from spdep_0.5-74, copies of non-exported functions

can.be.simmed <- function (listw) 
{
    res <- is.symmetric.nb(listw$neighbours, FALSE)
    if (res) {
        if (attr(listw$weights, "mode") == "general") 
            res <- attr(listw$weights, "glistsym")
    }
    else return(res)
    res
}

jacobianSetup <- function (method, env, con, pre_eig = NULL, trs = NULL, interval = NULL, 
    which = 1) 
{
    switch(method, eigen = {
        if (get("verbose", envir = env)) cat("neighbourhood matrix eigenvalues\n")
        if (is.null(pre_eig)) {
            eigen_setup(env, which = which)
        } else {
            eigen_pre_setup(env, pre_eig = pre_eig, which = which)
        }
        er <- get("eig.range", envir = env)
        if (is.null(interval)) interval <- c(er[1] + .Machine$double.eps, 
            er[2] - .Machine$double.eps)
    }, Matrix = {
        if (get("listw", envir = env)$style %in% c("W", "S") && 
            !get("can.sim", envir = env)) stop("Matrix method requires symmetric weights")
        if (get("listw", envir = env)$style %in% c("B", "C", 
            "U") && !(is.symmetric.glist(get("listw", envir = env)$neighbours, 
            get("listw", envir = env)$weights))) stop("Matrix method requires symmetric weights")
        if (get("verbose", envir = env)) cat("sparse matrix Cholesky decomposition\n")
        Imult <- con$Imult
        if (is.null(interval)) {
            if (get("listw", envir = env)$style == "B") {
                Imult <- ceiling((2/3) * max(sapply(get("listw", 
                  envir = env)$weights, sum)))
                interval <- c(-0.5, +0.25)
            } else interval <- c(-1, 0.999)
        }
        if (is.null(con$super)) con$super <- as.logical(NA)
        Matrix_setup(env, Imult, con$super, which = which)
    }, Matrix_J = {
        if (get("listw", envir = env)$style %in% c("W", "S") && 
            !get("can.sim", envir = env)) stop("Matrix method requires symmetric weights")
        if (get("listw", envir = env)$style %in% c("B", "C", 
            "U") && !(is.symmetric.glist(get("listw", envir = env)$neighbours, 
            get("listw", envir = env)$weights))) stop("Matrix method requires symmetric weights")
        if (get("verbose", envir = env)) cat("sparse matrix Cholesky decomposition\n")
        if (is.null(interval)) {
            if (get("listw", envir = env)$style == "B") {
                interval <- c(-0.5, +0.25)
            } else interval <- c(-1, 0.999)
        }
        if (is.null(con$super)) con$super <- FALSE
        Matrix_J_setup(env, super = con$super, which = which)
    }, spam = {
        ##if (!require(spam)) stop("spam not available") # spam is imported
        if (get("listw", envir = env)$style %in% c("W", "S") && 
            !get("can.sim", envir = env)) stop("spam method requires symmetric weights")
        if (get("listw", envir = env)$style %in% c("B", "C", 
            "U") && !(is.symmetric.glist(get("listw", envir = env)$neighbours, 
            get("listw", envir = env)$weights))) stop("spam method requires symmetric weights")
        if (get("verbose", envir = env)) cat("sparse matrix Cholesky decomposition\n")
        spam_setup(env, pivot = con$spamPivot, which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, spam_update = {
        ##if (!require(spam)) stop("spam not available") # idem
        if (get("listw", envir = env)$style %in% c("W", "S") && 
            !get("can.sim", envir = env)) stop("spam method requires symmetric weights")
        if (get("listw", envir = env)$style %in% c("B", "C", 
            "U") && !(is.symmetric.glist(get("listw", envir = env)$neighbours, 
            get("listw", envir = env)$weights))) stop("spam method requires symmetric weights")
        if (get("verbose", envir = env)) cat("sparse matrix Cholesky decomposition\n")
        spam_update_setup(env, in_coef = con$in_coef, pivot = con$spamPivot, 
            which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, Chebyshev = {
        if (get("listw", envir = env)$style %in% c("W", "S") && 
            !get("can.sim", envir = env)) stop("Chebyshev method requires symmetric weights")
        if (get("listw", envir = env)$style %in% c("B", "C", 
            "U") && !(is.symmetric.glist(get("listw", envir = env)$neighbours, 
            get("listw", envir = env)$weights))) stop("Chebyshev method requires symmetric weights")
        if (get("verbose", envir = env)) cat("sparse matrix Chebyshev approximation\n")
        cheb_setup(env, q = con$cheb_q, which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, MC = {
        if (!get("listw", envir = env)$style %in% c("W")) stop("MC method requires row-standardised weights")
        if (get("verbose", envir = env)) cat("sparse matrix Monte Carlo approximation\n")
        mcdet_setup(env, p = con$MC_p, m = con$MC_m, which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, LU = {
        if (get("verbose", envir = env)) cat("sparse matrix LU decomposition\n")
        LU_setup(env, which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, LU_prepermutate = {
        if (get("verbose", envir = env)) cat("sparse matrix LU decomposition\n")
        LU_prepermutate_setup(env, coef = con$in_coef, order = con$LU_order, 
            which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, moments = {
        if (get("verbose", envir = env)) cat("Smirnov/Anselin (2009) trace approximation\n")
        moments_setup(env, trs = trs, m = con$MC_m, p = con$MC_p, 
            type = con$type, correct = con$correct, trunc = con$trunc, 
            which = which)
        if (is.null(interval)) interval <- c(-1, 0.999)
    }, SE_classic = {
        if (get("verbose", envir = env)) cat("SE toolbox classic grid\n")
        if (is.null(interval)) interval <- c(-1, 0.999)
        if (con$SE_method == "MC" && !get("listw", envir = env)$style %in% 
            c("W")) stop("MC method requires row-standardised weights")
        SE_classic_setup(env, SE_method = con$SE_method, p = con$MC_p, 
            m = con$MC_m, nrho = con$nrho, interpn = con$interpn, 
            interval = interval, SElndet = con$SElndet, which = which)
    }, SE_whichMin = {
        if (get("verbose", envir = env)) cat("SE toolbox which.min grid\n")
        if (is.null(interval)) interval <- c(-1, 0.999)
        if (con$SE_method == "MC" && !get("listw", envir = env)$style %in% 
            c("W")) stop("MC method requires row-standardised weights")
        SE_whichMin_setup(env, SE_method = con$SE_method, p = con$MC_p, 
            m = con$MC_m, nrho = con$nrho, interpn = con$interpn, 
            interval = interval, SElndet = con$SElndet, which = which)
    }, SE_interp = {
        if (get("verbose", envir = env)) cat("SE toolbox which.min grid\n")
        if (is.null(interval)) interval <- c(-1, 0.999)
        if (con$SE_method == "MC" && !get("listw", envir = env)$style %in% 
            c("W")) stop("MC method requires row-standardised weights")
        SE_interp_setup(env, SE_method = con$SE_method, p = con$MC_p, 
            m = con$MC_m, nrho = con$nrho, interval = interval, 
            which = which)
    }, stop("...\n\nUnknown method\n"))
    interval
}




#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/olsmod.R"
olsmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, dim(X)[[2]]),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## this function just for compatibility:
    ## ML estimation of OLS model; produces (hopefully same)
    ## results as lm() and logLik.lm but as a 'splm' object

    ## good for any GLS estimation by ML, just supply the
    ## right sigma.1() function

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    #nam.errcomp <- c("psi")

    ## initialize values for optimizer
    ## (NULL is currently passed as coef0 if ols and lag=F)
    coef0 = rep(0, dim(X)[[2]])
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- -Inf
    upper.bounds <- Inf

    ## modules for likelihood
    ## (none)

    ## likelihood function, both steps included
    ll.c <- function(betas, y, X, n, t, w, w2) {
        ## get e, s2e as function of betas
        e <- y - X %*% betas                # lag-specific line (Ay for y)
        s2e <- crossprod(e)/(n*t)
        ## calc ll
        tre <- -n * t/2 * log(s2e)
        quattro <- -1/(2 * s2e) * crossprod(e)
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }


    ## GLS step function suppressed

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    betas <- optimum$par

    ## one last GLS step at optimal vcov parms suppressed

    ## final vcov(beta)
    e <- y - X %*% betas                # lag-specific line (Ay for y)
    s2e <- crossprod(e)/(n*t)
    covB <- as.numeric(s2e) * solve(crossprod(X))

    ## final vcov(errcomp)
    covAR <- NULL                                  # ols.errors-specific
    covPRL <- NULL                                 # ols.errors-specific

    ## final parms
    #betas ok
    arcoef <- NULL                                 # ols.errors-specific line
    errcomp <- NULL                                # ols.errors-specific
    names(betas) <- nam.beta
    #names(arcoef) <- "psi"                        # lag-specific line
    #names(errcomp) <- nam.errcomp[which(nam.errcomp!="psi")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    #dimnames(covAR) <- list(names(arcoef), names(arcoef))
    #dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = s2e)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/pbsjkARtest.R"
`pbsjkARtest` <-
function(formula, data, w, index=NULL, ...) {

  ## performs Baltagi, Song, Jung and Koh C.2 test
  ## for serial correlation conditional on RE and spatial corr.
  ## Giovanni Millo, Trieste, this version compatible with spreml()
  ## 19/03/2009

  ## depends: spreml()>semREmod(), fdHess{nlme} for numerical hessians

  #require(nlme) #not needed any more


  ## reorder data if needed
  if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  gindex <- data[,1]
  tindex <- data[,2]

  ## for our purpose data has to be (re)ordered
  ## by time, then group
  data <- data[order(tindex, gindex),]

  ## est. MLE SEM-RE model
  mymod <- spreml(formula=formula, data=data, w=w,
                  index=index, lag=FALSE, errors="semre", ...)

  nt. <- dim(data)[[1]]
  n. <- length(unique(gindex))
  t. <- length(unique(tindex))

  ## def. 'trace' function
  tr<-function(x) sum(diag(x))

  ## def. 'matrix square' function
  msq<-function(x) x%*%x

  ## make W matrix from listw object, if needed
  if("listw" %in% class(w)) w<-listw2mat(w) #if(require(spdep)) w<-listw2mat(w)

  ## retrieve restricted model's residuals ### substitute by a direct extraction
  X<-model.matrix(formula, data)
  y<-model.response(model.frame(formula,data))
  beta0<-mymod$coefficients
  u.hat<-as.numeric(y-X%*%beta0)

  ## retrieve SEM coefficient from model coef
  lambda <- mymod$errcomp["rho"]

  ## retrieve variance components sigma.e and sigma.mu from lme object
  eta <- mymod$errcomp["phi"]  # pay attention to this renaming
  sigma2tot <- as.numeric(crossprod(u.hat)/nt.)
  sigma2e <- as.numeric(sigma2tot/(eta+1))
  sigma2mu <- as.numeric(eta*sigma2e)

  ## henceforth notation as in Baltagi, Song, Jung, Koh (JE 2007)

  JaT<-matrix(1,nrow=t.,ncol=t.)/t.
  It<-diag(1,t.)
  Et<-It-JaT


  B<-diag(1,n.)-lambda*w
  BB<-crossprod(B)
  BB.1 <- solve(BB)

  wBBw<-crossprod(w,B)+crossprod(B,w)

  Z0 <- solve( t. * sigma2mu * diag(1,n.) + sigma2e * BB.1 )

  G<-matrix(0,ncol=t.,nrow=t.)
  for(i in 2:t.) {
    G[i-1,i]<-1
    G[i,i-1]<-1
    }

  EGE <- Et%*%G%*%Et
  JGE <- JaT%*%G%*%Et
  EGJ <- Et%*%G%*%JaT
  JGJ <- JaT%*%G%*%JaT


  redspade <- 1/sigma2e^2*kronecker(EGE,BB) + 1/sigma2e*kronecker(JGE,Z0) +
              1/sigma2e*kronecker(EGJ,Z0) + kronecker(JGJ,Z0%*%BB.1%*%Z0)

  Dhat <- -(t.-1)/t. * (sigma2e * tr(Z0%*%BB.1) -n.) +
          1/2 * sigma2e * crossprod(u.hat, redspade) %*% u.hat

  ## information matrix:
  d1<-tr( msq(Z0%*%BB.1) )
  d2<-tr(Z0%*%BB.1%*%Z0)
  d3<-tr( wBBw%*%BB.1 )
  d4<-tr( Z0 %*% BB.1 %*% wBBw %*% BB.1 %*% Z0 %*% BB.1 )
  d5<-tr( Z0 %*% BB.1 %*% wBBw %*% BB.1 %*% Z0 )
  d6<-tr( msq( wBBw %*% BB.1 ) )
  d7<-tr( msq( Z0 %*% BB.1 %*% wBBw %*% BB.1 ) )

  j11<-(n.*(t.-1)/sigma2e^2 + d1)/2
  j12<-t./2*d2
  j13<-(t.-1)/t.*(sigma2e*d1-n./sigma2e)
  j14<-((t.-1)/sigma2e*d3 + sigma2e*d4)/2
  j22<-t.^2/2*tr(msq(Z0))
  j23<-(t.-1)*sigma2e*d2
  j24<-t./2*sigma2e*d5
  j33<-n./t.^2 * (t.^3-3*t.^2+2*t.+2) + (2*(t.-1)^2*sigma2e^2)/t.^2*d1
  j34<-(t.-1)/t. * (sigma2e^2*d4 - d3)
  j44<-((t.-1)*d6 + sigma2e^2*d7)/2

  Jtheta<-matrix(ncol=4,nrow=4)
  Jtheta[1,]<-c(j11,j12,j13,j14)
  Jtheta[2,]<-c(j12,j22,j23,j24)
  Jtheta[3,]<-c(j13,j23,j33,j34)
  Jtheta[4,]<-c(j14,j24,j34,j44)

  J33.1<-solve(Jtheta)[3,3]

  LMr.lm <- (Dhat^2) * J33.1

  df.<-1
  pval <- pchisq(LMr.lm,df=df.,lower.tail=FALSE)

  names(LMr.lm)="LM"
  names(df.)<-"df"

  ##(insert usual htest features)
  dname <- deparse(formula)
  RVAL <- list(statistic = LMr.lm, parameter = df.,
               method = "Baltagi, Song, Jung and Koh C.2 conditional test",
               alternative = "serial corr. in error terms, sub RE and spatial dependence",
               p.value = pval,
               data.name =   dname)
  class(RVAL) <- "htest"
  return(RVAL)

}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/pbsjkJtest.R"
`pbsjkJtest` <-
function(formula, data, w, index=NULL, ...) {

  ## performs Baltagi, Song, Jung and Koh J(oint) test
  ## for RE, serial correlation and spatial corr.
  ## Giovanni Millo, Trieste, this version: 19/03/2009

  ## for our purpose data has to be (re)ordered
  ## by time, then group (but this is cared for just below)

  ## reorder data if needed
  if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  gindex <- data[,1]
  tindex <- data[,2]

  ## for our purpose data has to be (re)ordered
  ## by time, then group
  data <- data[order(tindex, gindex),]

  ## def. 'trace' function
  tr<-function(x) sum(diag(x))

  ## def. 'matrix square' function
  msq<-function(x) x%*%x

  ## make W matrix from listw object, if needed
  if("listw" %in% class(w)) w <- listw2mat(w) #if(require(spdep)) w<-listw2mat(w)

  ## retrieve restricted model's (OLS) residuals (ordered!)
  X<-model.matrix(formula, data)
  y<-model.response(model.frame(formula,data))
  beta0<-lm(y~X-1)$coef
  u.hat<-y-X%*%beta0

  ## calc. data numerosities (do it better)
  nt.<- length(y)
  n.<- dim(w)[[1]]
  t.<-nt./n.

  ## henceforth notation as in Baltagi, Song, Jung, Koh (JE 2007)
  Jt<-matrix(1,ncol=t.,nrow=t.)
  In<-diag(1,n.)
  It<-diag(1,t.)
  G<-matrix(0,ncol=t.,nrow=t.)
  for(i in 2:t.) {
    G[i-1,i]<-1
    G[i,i-1]<-1
    }

  ## NB do all this without Kronecker prods.!
  A <- (crossprod(u.hat, kronecker(Jt, In)) %*% u.hat)/crossprod(u.hat)-1
  F <- 1/2 * (crossprod(u.hat, kronecker(G, In)) %*% u.hat)/crossprod(u.hat)
  H <- 1/2 * (crossprod(u.hat, kronecker(It, (t(w)+w))) %*% u.hat)/crossprod(u.hat)
  b <- tr(msq(w+t(w)))/2

  LMj <- n.*t.^2 / (2*(t.-1)*(t.-2)) * (A^2 - 4*A*F + 2*t.*F^2) + (n.^2*t.)/b*H^2

  df.<-3
  pval <- pchisq(LMj,df=df.,lower.tail=FALSE)

  names(LMj)="LM"
  names(df.)<-"df"

  ##(insert usual htest features)
  dname <- deparse(formula)
  RVAL <- list(statistic = LMj, parameter = df.,
               method = "Baltagi, Song, Jung and Koh joint test (J)",
               alternative = "random effects or serial corr. or spatial dependence in error terms",
               p.value = pval,
               data.name =   dname)
  class(RVAL) <- "htest"
  return(RVAL)

}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/pbsjkSDtest.R"
`pbsjkSDtest` <-
function(formula, data, w, index=NULL, ...) {

  ## performs Baltagi, Song, Jung and Koh C.1 test
  ## for spatial dependence conditional on RE and serial corr.
  ## Giovanni Millo, Trieste, this version 2: 19/03/2009

  ## new interface for operation with pbsjktest2.R--> and
  ## -->spreml.R

  ## NB! not the same numbers as in the nlme-based version!!
  ## ...but these look like fitting better with a Wald test
  ## on semsrre

  ## depends: spreml()>ssrREmod(), fdHess{nlme} for numerical hessians

  #require(nlme) # not needed any more

  ## reorder data if needed
  if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  gindex <- data[,1]
  tindex <- data[,2]

  ## for our purpose data has to be (re)ordered
  ## by time, then group
  data <- data[order(tindex, gindex),]

  ## est. MLE AR-RE model
  mymod <- spreml(formula=formula, data=data, w=w,
                  index=index, lag=FALSE, errors="srre", ...)

  ## def. 'trace' function
  tr<-function(x) sum(diag(x))

  nt. <- dim(data)[[1]]
  n. <- length(unique(gindex))
  t. <- length(unique(tindex))
  Jt<-matrix(1,ncol=t.,nrow=t.)

  ## make W matrix from listw object, if needed
  if("listw" %in% class(w)) w<-listw2mat(w) #if(require(spdep)) w<-listw2mat(w)

  ## retrieve restricted model's residuals ### substitute by a direct extraction
  X<-model.matrix(formula, data)
  y<-model.response(model.frame(formula,data))
  beta0<-mymod$coefficients
  u.hat<-as.numeric(y-X%*%beta0)

  ## retrieve AR(1) coefficient
  rho<-mymod$errcomp["psi"] # notice change in parm names in spreml

  ## henceforth notation as in Baltagi, Song, Jung, Koh (JE 2007)

  b<-tr(w%*%w+crossprod(w))

  d2<-(1+rho)/(1-rho)+t.-1

  ## retrieve variance components sigma.e and sigma.mu from lme object
  sigma2tot<-sum(u.hat^2)/length(u.hat)
  phi<- mymod$errcomp["phi"]  ## sigmatot^2=sigma.e^2*(phi+1)
  sigma2.e<-sigma2tot/(phi+1)
  sigma2.u<-sigma2tot-sigma2.e

  sigma.e<-sqrt(sigma2.e)
  sigma.u<-sqrt(sigma2.u)

  c. <- (sigma.e^2 * sigma.u^2) / (d2*(1-rho)^2*sigma.u^2+sigma.e^2)

  g. <- (1-rho)/sigma.e^2 * ( 2 + (t.-2)*(1-rho) )

  V1<-matrix(ncol=t.,nrow=t.)
  for(i in 1:t.) V1[i,]<-rho^abs(1:t.-i)

  V <- sigma.e^2 * (1/(1-rho^2)) * V1
  iV<-solve(V)
  VJt <- solve(V,Jt)

  bluestar<-(iV - 2*c. * VJt %*% iV +
             c.^2 * VJt%*%VJt %*% iV)

  bluespade<-kronecker(bluestar,(t(w)+w))

  Dhat <- 1/2 * crossprod(u.hat, bluespade) %*% u.hat

  LMl.rm <- (Dhat^2) / (b*(t. - 2*c.*g. + c.^2*g.^2))

  df.<-1
  pval <- pchisq(LMl.rm,df=df.,lower.tail=FALSE)

  names(LMl.rm)="LM"
  names(df.)<-"df"

  ##(insert usual htest features)
  dname <- deparse(formula)
  RVAL <- list(statistic = LMl.rm, parameter = df.,
               method = "Baltagi, Song, Jung and Koh C.1 conditional test",
               alternative = "spatial dependence in error terms, sub RE and serial corr.",
               p.value = pval,
               data.name =   dname)
  class(RVAL) <- "htest"
  return(RVAL)

}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/print.splm.R"
`print.splm` <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
    cat("\nCall:\n", deparse(x$call), "\n\n", sep = "")
    if (length(coef(x))) {
        cat("Coefficients:\n")
        print.default(format(coef(x), digits = digits), print.gap = 2,
                      quote = FALSE)
    } else {
        cat("No coefficients\n")
    }

    ## add printing of error variance parameters
    cat("\n")
    ec <- x$errcomp
    if (length(ec)) {
        cat("Error covariance parameters:\n")
        print.default(format(ec, digits = digits), print.gap = 2,
                      quote = FALSE)
    }

    else cat("No error covariance parameters\n")
    cat("\n")

    ## add printing of spatial autoregressive parameter
    ar <- x$arcoef
    if (length(ar)) {
        cat("\n")
        cat("Spatial autoregressive parameter:\n")
        print.default(format(ar, digits = digits), print.gap = 2,
                      quote = FALSE)
    }

    invisible(x)
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/print.summary.splm.R"
`print.summary.splm` <-
function(x,digits= max(3, getOption("digits") - 2),width=getOption("width"),...) {


        cat(paste("Spatial panel",x$type,"model\n"))
        cat("\nCall:\n")
        print(x$call)
        cat("\nResiduals:\n")
        save.digits <- unlist(options(digits=digits))
        on.exit(options(digits=save.digits))
        print(sumres(x))

        if(!is.null(x$ErrCompTable)) {
            cat("\nError variance parameters:\n")
            printCoefmat(x$ErrCompTable,digits=digits,signif.legend=FALSE)
        }

        if(is.numeric(x$lambda)) {
            cat("\nEstimated spatial coefficient, variance components and theta:\n")
            print(x$lambda)
        }

        if(!is.null(x$ARCoefTable)) {
            cat("\nSpatial autoregressive coefficient:\n")
            printCoefmat(x$ARCoefTable,digits=digits,signif.legend=FALSE)
        }

        cat("\nCoefficients:\n")
        printCoefmat(x$CoefTable,digits=digits)
        cat("\n")

   

    invisible(x)
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarREmod.R"
sarREmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## change this to 'bdsmatrix'
    #require(kinship)

    # mark
    #print("uso versione 1") # fixed vcov.arcoef, was missing

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999)      # lag-specific line (2nd parm)
    upper.bounds <- c(1e08, 0.999)        # lag-specific line (idem)

    ## here first y is lagged using the data as sent from spreml()
    ## then observations are reordered like in standard panels, to exploit
    ## the fact that in this case the vcov matrix is block-diagonal

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## the sigma matrix is inverted during the GLS step and not before as
    ## in the other cases, to take advantage of specialized methods in the
    ## 'kinship' (migrate to --> 'bdsmatrix'!) package

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    B <- function(lambda, w) diag(1, ncol(w)) - lambda * w
    detB <- function(lambda, w) det(B(lambda, w))
    bSigma <- function(phipsi, n, t, w) {
        ## single block of the original
        ## maintain w for homogeneity with generic part
        Jt <- matrix(1, ncol = t, nrow = t)
        It <- diag(1, t)
        ## retrieve parms
        phi <- phipsi[1]
        ## psi not used: here passing 2 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        bSigma <- phi * Jt + It
        bSigma
    }
    detSigma <- function(phi, n, t) {
        detSigma <- -n/2 * log(t * phi + 1)
        detSigma
    }
    fullSigma <- function(phipsi, n, t, w) {
        sigma.i <- bSigma(phipsi, n, t, w)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }


    ## likelihood function, both steps included
    ll.c <- function(phipsi, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        phi <- phipsi[1]
        psi <- phipsi[2]                          # lag-specific line
        ## calc sigma (here not inverted)
        sigma <- fullSigma(phipsi, n, t, w)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, Ay, sigma)        # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        due <- detSigma(phi, n, t)
        tre <- -(n * t)/2 * log(s2e)
        cinque <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic-ssr from here

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstepBDS(X, Ay, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))
    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp) - 1
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## remember to rearrange any output as x <- x[oo.0]

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarem2REmod.R"
sarem2REmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 27/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## now using flex optimization and sparse matrix methods

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    invSigma <- function(philambda, n, t., w) {
        Jt <- matrix(1, ncol = t., nrow = t.)
        #In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker( (1/(t.*phi+1)*Jbart + Et), BB )
        invSigma
    }
    detSigma <- function(phi, lambda, n, t., w) {
         Jt <- matrix(1, ncol = t., nrow = t.)
        #In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        detSigma <- -n/2*log( det( (t.*phi+1) * Jbart + Et) ) +
            t.*ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(philambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        psi <- philambda[3]                       # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(philambda, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        due <- detSigma(phi, lambda, n, t., w2)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(1e+09, 0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,4)),
               c(0,1,-1,rep(0,2)),
               c(rep(0,3), 1, -1))
    cB <- c(0, rep(1,4))
    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }


    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarem2srREmod.R"
sarem2srREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 4),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb",
          ...)
{

    ## New KKP+SR estimator, Giovanni Millo 12/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## needs ldetB(), xprodB()

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi", "rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    Vmat <- function(rho, t.) {
        V1 <- matrix(ncol = t., nrow = t.)
        for (i in 1:t.) V1[i, ] <- rho^abs(1:t. - i)
        V <- (1/(1 - rho^2)) * V1
    }
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t.) alfa2(rho) + t. - 1
    Jt <- matrix(1, ncol = t., nrow = t.)
    In <- diag(1, n)
    det2 <- function(phi, rho, lambda, t., w) (d2(rho, t.) * (1 -
        rho)^2 * phi + 1)
    invSigma <- function(phirholambda, n, t., w) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)    #
        BB <- xprodB(lambda, w)
        chi <- phi/(d2(rho, t.)*(1-rho)^2*phi+1)
        invSigma <- kronecker((invVmat-chi*(invVmat %*% Jt %*% invVmat)),
                              BB)
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(phirholambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        psi <- phirholambda[4]                    # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(phirholambda, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)    #log(detB(psi, w)) # lag-specific line (else zero <- 0)
        uno <- n/2 * log(1 - rho^2)
        due <- -n/2 * log(det2(phi, rho, lambda, t., w2))
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- (t.) * ldetB(lambda, w2)      #log(detB(lambda, w2))
        cinque <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + due + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(1e+09, 0.999, 0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,6)),
               c(0,1,-1,rep(0,4)),
               c(rep(0,3), 1, -1, rep(0,2)),
               c(rep(0,5), 1, -1))
    cB <- c(0, rep(1,6))

    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line


    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/saremREmod.R"
saremREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    # mark
    #print("uso versione 0") # done from saremsrREmod4.R

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    invSigma <- function(philambda, n, t., w) {
        Jt <- matrix(1, ncol = t., nrow = t.)
        In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(Jbart,
                              solve(t. * phi * In + BB.1(lambda, w))) +
                                  kronecker(Et, BB)
        invSigma
    }
    detSigma <- function(phi, lambda, n, t., w) {
        In <- diag(1, n)
        detSigma <- -1/2 * log(det(t. * phi * In +
                                   BB.1(lambda, w))) +
                                       (t. - 1) * ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(philambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        psi <- philambda[3]                       # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(philambda, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        due <- detSigma(phi, lambda, n, t., w2)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * crossprod(e, sigma.1) %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(1e+09, 0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,4)),
               c(0,1,-1,rep(0,2)),
               c(rep(0,3), 1, -1))
    cB <- c(0, rep(1,4))


    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(crossprod(X, sigma.1) %*% X,
                       crossprod(X, sigma.1) %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (crossprod(ehat, sigma.1) %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, sigma.1) %*% X)

    ## final vcov(errcomp)

    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/saremmod.R"
saremmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 27/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    # mark
    #print("uso versione 0") # done from saremsrREmod4.R

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    invSigma <- function(lambdapsi, n, t., w) {
        It <- diag(1, t.)
        ## retrieve parms
        lambda <- lambdapsi[1]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(It, BB)
        invSigma
    }
    detSigma <- function(lambda, t., w) {
        detSigma <- t. * ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(lambdapsi, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        lambda <- lambdapsi[1]
        psi <- lambdapsi[2]                       # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(lambdapsi, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        due <- detSigma(lambda, t., w2)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(-0.999, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1,-1,rep(0,2)),
               c(rep(0,2), 1, -1))
    cB <- c(rep(1,4))
    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

     ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/saremsrREmod.R"
saremsrREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 4),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb",
          ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## from version 2: both nlminb (fastest, some negative covariances) and
    ## optimizers from maxLik ("BFGS", "SANN", "NM") are supported.

    ## from version 3: analytical inverse for Vmat (see notes; eliminates
    ## singular matrix pbs., from ca. 45'' to ca. 30'' on 281x3 'datiNY' example)
    ## and exploit the fact that solve(crossprod(B))=tcrossprod(solve(B))
    ## (this last not giving any benefit; but check sparse methods on B)

    ## this version 4 (5/3/2013): sparse matrix methods if w, w2 is a 'listw'
    ## needs ldetB(), solveB(), xprodB()
    ##
    ## almost no gain on medium-sized listwNY example, T=3

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi", "rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t.) alfa2(rho) + t. - 1
    Jt <- matrix(1, ncol = t., nrow = t.)
    In <- diag(1, n)
    det2 <- function(phi, rho, lambda, t., w) det(d2(rho, t.) * (1 -
        rho)^2 * phi * In + BB.1(lambda, w))
    Z0 <- function(phi, rho, lambda, t., w) solve(d2(rho, t.) * (1 -
        rho)^2 * phi * In + BB.1(lambda, w))
    invSigma <- function(phirholambda, n, t., w) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)    #
        BB <- xprodB(lambda, w)
        invSi1 <- kronecker(invVmat, BB)
        invSi2 <- 1/(d2(rho, t.) * (1 - rho)^2)
        invSi3 <- kronecker(invVmat %*% Jt %*% invVmat,  #
            Z0(phi, rho, lambda, t., w) - BB)
        invSigma <- invSi1 + invSi2 * invSi3
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(phirholambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        psi <- phirholambda[4]                    # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(phirholambda, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)     # lag-specific line (else zero <- 0)
        uno <- n/2 * log(1 - rho^2)
        due <- -1/2 * log(det2(phi, rho, lambda, t., w2))
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- (t. - 1) * ldetB(lambda, w2)
        cinque <- -1/(2 * s2e) * crossprod(e, sigma.1) %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + due + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(1e+09, 0.999, 0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,6)),
               c(0,1,-1,rep(0,4)),
               c(rep(0,3), 1, -1, rep(0,2)),
               c(rep(0,5), 1, -1))
    cB <- c(0, rep(1,6))

    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(crossprod(X, sigma.1) %*% X,
                       crossprod(X, sigma.1) %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (crossprod(ehat, sigma.1) %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, sigma.1) %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/saremsrmod.R"
saremsrmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    # mark
    #print("uso versione 0")

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("psi", "rho", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer

    ## modules for likelihood
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    invSigma <- function(rholambda, n, t., w) {
        ## retrieve parms
        rho <- rholambda[1]
        lambda <- rholambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(invVmat, BB)
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(rholambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        rho <- rholambda[1]
        lambda <- rholambda[2]
        psi <- rholambda[3]                       # lag-specific line
        ## calc inverse sigma
        sigma.1 <- invSigma(rholambda, n, t., w2)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, Ay, sigma.1)         # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t.*ldetB(psi, w)                  # lag-specific line (else zero <- 0)
        uno <- n/2 * log(1 - rho^2)
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- t. * ldetB(lambda, w2)
        cinque <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(-0.999, -0.999, -0.999)  # lag-specific line (3rd parm)
    upper.bounds <- c(0.999, 0.999, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1,-1,rep(0,4)),
               c(rep(0,2), 1, -1, rep(0,2)),
               c(rep(0,4), 1, -1))
    cB <- rep(1,6)

    ## generic from here

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2, wy))$Hessian     # lag-specific line: wy

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2, wy) {
            -ll.c(phirholambda, y, X, n, t., w, w2, wy)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2, wy = wy)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstep(X, Ay, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarmod.R"
sarmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = 0,
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 04/10/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## optimized with OLS step instead of GLS

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("lambda")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(-0.999)    # lag-specific line (3rd parm)
    upper.bounds <- c(0.999)     # lag-specific line (idem)

    ## modules for likelihood
    B <- function(lambda, w) diag(1, ncol(w)) - lambda * w
    detB <- function(lambda, w) det(B(lambda, w))

    ## likelihood function, both steps included
    ll.c <- function(phipsi, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        psi <- phipsi                             # lag-specific line
        ## calc inverse sigma not needed (is I_n)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do OLS step to get e, s2e
        glsres <- OLSstep(X, Ay)                  # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t*ldetB(psi, w2)              # lag-specific line (else zero <- 0)
        due <- 0
        tre <- -n * t/2 * log(s2e)
        quattro <- -1/(2 * s2e) * crossprod(e)
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic from here

    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## OLS step function (notice: OLS here)
    OLSstep <- function(X, y) {
        b.hat <- solve(crossprod(X), crossprod(X, y))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat)/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- OLSstep(X, Ay)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X))

    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp) - 1
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- NULL                                # ols.errors-specific

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- NULL                               # ols.errors-specific
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    #names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    #dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarsrREmod.R"
sarsrREmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## change this to 'bdsmatrix'
    #require(bdsmatrix)

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi", "lambda")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999)      # lag-specific line (3rd parm)
    upper.bounds <- c(1e+09, 0.999, 0.999)        # lag-specific line (idem)

    ## here first y is lagged using the data as sent from spreml()
    ## then observations are reordered like in standard panels, to exploit
    ## the fact that in this case the vcov matrix is block-diagonal

     ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## the sigma matrix is inverted during the GLS step and not before as
    ## in the other cases, to take advantage of specialized methods in the
    ## 'kinship' (migrate to --> 'bdsmatrix'!) package

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    Vmat <- function(rho, t) {
        V1 <- matrix(ncol = t, nrow = t)
        for (i in 1:t) V1[i, ] <- rho^abs(1:t - i)
        V <- (1/(1 - rho^2)) * V1
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t) alfa2(rho) + t - 1
    bSigma <- function(phirho, n, t) {
        phi <- phirho[1]
        rho <- phirho[2]
        Jt <- matrix(1, ncol = t, nrow = t)
        bSigma <- phi * Jt + Vmat(rho, t)
        bSigma
    }
    fullSigma <- function(phirho, n, t) {
        phi <- phirho[1]
        rho <- phirho[2]
        ## psi not used: here passing 3 parms, but works anyway
        ## because psi is last one
        sigma.i <- bSigma(phirho, n, t)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }


    ## likelihood function, both steps included
    ll.c <- function(phirho, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        phi <- phirho[1]
        rho <- phirho[2]
        psi <- phirho[3]                          # lag-specific line
        ## calc sigma (here not inverted)
        sigma <- fullSigma(phirho, n, t)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, Ay, sigma)        # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        uno <- n/2 * log(1 - rho^2)
        due <- -n/2 * log(d2(rho, t) * (1 - rho)^2 * phi + 1)
        tre <- -(n * t)/2 * log(s2e)
        cinque <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + zero + uno + due + tre + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic-ssr from here

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstepBDS(X, Ay, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))
    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp) - 1
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## remember to rearrange any output as x <- x[oo.0]

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sarsrmod.R"
sarsrmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## change this to 'bdsmatrix'
    #require(kinship)

    # mark
    #print("uso versione 1") # fixed vcov.arcoef, was missing

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("psi","lambda")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(-0.999, -0.999)      # lag-specific line (2nd parm)
    upper.bounds <- c(0.999, 0.999)        # lag-specific line (idem)

    ## here first y is lagged using the data as sent from spreml()
    ## then observations are reordered like in standard panels, to exploit
    ## the fact that in this case the vcov matrix is block-diagonal

    ## calc. Wy (spatial lag of y)
    ## (flexible fun accepting either listws or matrices for w)
    Wy <- function(y, w, tind) {                  # lag-specific line
        wyt <- function(y, w) {                   # lag-specific line
            if("listw" %in% class(w)) {           # lag-specific line
                wyt <- lag.listw(w, y)            # lag-specific line
            } else {                              # lag-specific line
                wyt <- w %*% y                    # lag-specific line
            }                                     # lag-specific line
            return(wyt)                           # lag-specific line
        }                                         # lag-specific line
        wy<-list()                                # lag-specific line
        for (j in 1:length(unique(tind))) {       # lag-specific line
             yT<-y[tind==unique(tind)[j]]         # lag-specific line
             wy[[j]] <- wyt(yT, w)                # lag-specific line
             }                                    # lag-specific line
        return(unlist(wy))                        # lag-specific line
    }                                             # lag-specific line

    ## lag y once for all
    wy <- Wy(y, w, tind)                          # lag-specific line

    ## the sigma matrix is inverted during the GLS step and not before as
    ## in the other cases, to take advantage of specialized methods in the
    ## 'kinship' (migrate to --> 'bdsmatrix'!) package

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    Vmat <- function(rho, t) {
        V1 <- matrix(ncol = t, nrow = t)
        for (i in 1:t) V1[i, ] <- rho^abs(1:t - i)
        V <- (1/(1 - rho^2)) * V1
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t) alfa2(rho) + t - 1
    bSigma <- function(phirho, n, t) {
        ## this is kept for standardization, as here bSigma=Vmat
        rho <- phirho[1]
        bSigma <- Vmat(rho, t) # simply
        bSigma
    }
    fullSigma <- function(phirho, n, t) {
        rho <- phirho[1]
        ## psi not used: here passing 2 parms, but works anyway
        ## because psi is last one
        sigma.i <- bSigma(phirho, n, t)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }


    ## likelihood function, both steps included
    ll.c <- function(phirho, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        rho <- phirho[1]
        psi <- phirho[2]                          # lag-specific line
        ## calc sigma (here not inverted)
        sigma <- fullSigma(phirho, n, t)
        ## lag y
        Ay <- y - psi * wy                        # lag-specific line
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, Ay, sigma)        # lag-specific line (Ay for y)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- t*ldetB(psi, w)              # lag-specific line (else zero <- 0)
        uno <- n/2 * log(1 - rho^2)
        tre <- -(n * t)/2 * log(s2e)
        cinque <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + zero + uno + tre + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic-ssr from here

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t)
    Ay <- y - myparms[length(myparms)] * wy       # lag-specific line
    beta <- GLSstepBDS(X, Ay, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))
    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp) - 1
    covAR <- covTheta[nvcovpms+1, nvcovpms+1, drop=FALSE]
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- myparms[which(nam.errcomp=="lambda")]  # lag-specific line
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(arcoef) <- "lambda"                        # lag-specific line
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covAR) <- list(names(arcoef), names(arcoef))
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## remember to rearrange any output as x <- x[oo.0]

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sem2REmod.R"
sem2REmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 27/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## now using flex optimization and sparse matrix methods
    
    ## if w2!=w has been specified, then let w=w2
    w <- w2
    
    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "rho")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    B <- function(lambda, w) diag(1, ncol(w)) - lambda * w
    detB <- function(lambda, w) det(B(lambda, w))
    invSigma <- function(philambda, n, t., w) {
        Jt <- matrix(1, ncol = t., nrow = t.)
        #In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker( (1/(t.*phi+1)*Jbart + Et), BB )
        invSigma
    }
    detSigma <- function(phi, lambda, n, t., w) {
         Jt <- matrix(1, ncol = t., nrow = t.)
        #In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        detSigma <- -n/2*log( det( (t.*phi+1) * Jbart + Et) ) +
            t.*ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(philambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## calc inverse sigma
        sigma.1 <- invSigma(philambda, n, t., w)
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        due <- detSigma(phi, lambda, n, t., w)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(1e+09, 0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,2)),
               c(0,1,-1))
    cB <- c(0, rep(1,2))
    ## generic from here

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian
    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }


    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sem2srREmod.R"
sem2srREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 4),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb",
          ...)
{

    ## New KKP+SR estimator, Giovanni Millo 12/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## needs ldetB(), xprodB()
    
    ## if w2!=w has been specified, then let w=w2
    w <- w2 # uses only w2, but just in case...

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi", "rho")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    Vmat <- function(rho, t.) {
        V1 <- matrix(ncol = t., nrow = t.)
        for (i in 1:t.) V1[i, ] <- rho^abs(1:t. - i)
        V <- (1/(1 - rho^2)) * V1
    }
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t.) alfa2(rho) + t. - 1
    Jt <- matrix(1, ncol = t., nrow = t.)
    In <- diag(1, n)
    det2 <- function(phi, rho, lambda, t., w) (d2(rho, t.) * (1 -
        rho)^2 * phi + 1)
    invSigma <- function(phirholambda, n, t., w) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)    #
        BB <- xprodB(lambda, w)
        chi <- phi/(d2(rho, t.)*(1-rho)^2*phi+1)
        invSigma <- kronecker((invVmat-chi*(invVmat %*% Jt %*% invVmat)),
                              BB)
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(phirholambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## calc inverse sigma
        sigma.1 <- invSigma(phirholambda, n, t., w2)
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        uno <- n/2 * log(1 - rho^2)
        due <- -n/2 * log(det2(phi, rho, lambda, t., w2))
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- (t.) * ldetB(lambda, w2)
        cinque <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + due + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999)
    upper.bounds <- c(1e+09, 0.999, 0.999)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,4)),
               c(0,1,-1,rep(0,2)),
               c(rep(0,3), 1, -1))
    cB <- c(0, rep(1,4))

    ## generic from here

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }


    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/semREmod.R"
semREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## if w2!=w has been specified, then let w=w2
    w <- w2
    
    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "rho")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    invSigma <- function(philambda, n, t., w) {
        Jt <- matrix(1, ncol = t., nrow = t.)
        In <- diag(1, n)
        It <- diag(1, t.)
        Jbart <- Jt/t.
        Et <- It - Jbart
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(Jbart,
                              solve(t. * phi * In + BB.1(lambda, w))) +
                                  kronecker(Et, BB)
        invSigma
    }
    detSigma <- function(phi, lambda, n, t., w) {
        In <- diag(1, n)
        detSigma <- -1/2 * log(det(t. * phi * In +
                                   BB.1(lambda, w))) +
                                       (t. - 1) * ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(philambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        phi <- philambda[1]
        lambda <- philambda[2]
        ## calc inverse sigma
        sigma.1 <- invSigma(philambda, n, t., w2)
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        due <- detSigma(phi, lambda, n, t., w2)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * crossprod(e, sigma.1) %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999)
    upper.bounds <- c(1e+09, 0.999)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,2)),
               c(0,1,-1))
    cB <- c(0, rep(1,2))


    ## generic from here

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(crossprod(X, sigma.1) %*% X,
                       crossprod(X, sigma.1) %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (crossprod(ehat, sigma.1) %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, sigma.1) %*% X)

    ## final vcov(errcomp)

    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/semmod.R"
semmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 27/03/2013
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## if w2!=w has been specified, then let w=w2
    w <- w2
    
    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("rho")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    invSigma <- function(lambdapsi, n, t., w) {
        It <- diag(1, t.)
        ## retrieve parms
        lambda <- lambdapsi[1]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(It, BB)
        invSigma
    }
    detSigma <- function(lambda, t., w) {
        detSigma <- t. * ldetB(lambda, w)
        detSigma
    }

    ## likelihood function, both steps included
    ll.c <- function(lambdapsi, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        lambda <- lambdapsi[1]
        ## calc inverse sigma
        sigma.1 <- invSigma(lambdapsi, n, t., w)
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        due <- detSigma(lambda, t., w)
        tre <- -n * t./2 * log(s2e)
        quattro <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + due + tre + quattro
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(-0.999)  # lag-specific line (4th parm)
    upper.bounds <- c(0.999)     # lag-specific line (idem)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- matrix(c(1,-1), ncol=1)
    cB <- c(rep(1,2))
    ## generic from here

     ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

     ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian
    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/semsrREmod.R"
semsrREmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 4),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb",
          ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## from version 2: both nlminb (fastest, some negative covariances) and
    ## optimizers from maxLik ("BFGS", "SANN", "NM") are supported.

    ## from version 3: analytical inverse for Vmat (see notes; eliminates
    ## singular matrix pbs., from ca. 45'' to ca. 30'' on 281x3 'datiNY' example)
    ## and exploit the fact that solve(crossprod(B))=tcrossprod(solve(B))
    ## (this last not giving any benefit; but check sparse methods on B)

    ## this version 4 (5/3/2013): sparse matrix methods if w, w2 is a 'listw'
    ## needs ldetB(), solveB(), xprodB()
    ##
    ## almost no gain on medium-sized listwNY example, T=3
    
    ## if w2!=w has been specified, then let w=w2
    w <- w2 # uses w2 everywhere, but just to be sure...
    
    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi", "rho")

    ## initialize values for optimizer
    myparms0 <- coef0

    ## modules for likelihood
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t.) alfa2(rho) + t. - 1
    Jt <- matrix(1, ncol = t., nrow = t.)
    In <- diag(1, n)
    det2 <- function(phi, rho, lambda, t., w) det(d2(rho, t.) * (1 -
        rho)^2 * phi * In + BB.1(lambda, w))
    Z0 <- function(phi, rho, lambda, t., w) solve(d2(rho, t.) * (1 -
        rho)^2 * phi * In + BB.1(lambda, w))
    invSigma <- function(phirholambda, n, t., w) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)    #
        BB <- xprodB(lambda, w)
        invSi1 <- kronecker(invVmat, BB)
        invSi2 <- 1/(d2(rho, t.) * (1 - rho)^2)
        invSi3 <- kronecker(invVmat %*% Jt %*% invVmat,  #
            Z0(phi, rho, lambda, t., w) - BB)
        invSigma <- invSi1 + invSi2 * invSi3
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(phirholambda, y, X, n, t., w, w2) {
        ## retrieve parms
        phi <- phirholambda[1]
        rho <- phirholambda[2]
        lambda <- phirholambda[3]
        ## calc inverse sigma
        sigma.1 <- invSigma(phirholambda, n, t., w2)
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        uno <- n/2 * log(1 - rho^2)
        due <- -1/2 * log(det2(phi, rho, lambda, t., w2))
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- (t. - 1) * ldetB(lambda, w2)
        cinque <- -1/(2 * s2e) * crossprod(e, sigma.1) %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + due + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999, -0.999)
    upper.bounds <- c(1e+09, 0.999, 0.999)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1, rep(0,4)),
               c(0,1,-1,rep(0,2)),
               c(rep(0,3), 1, -1))
    cB <- c(0, rep(1,4))

    ## generic from here

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(crossprod(X, sigma.1) %*% X,
                       crossprod(X, sigma.1) %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (crossprod(ehat, sigma.1) %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w2)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, sigma.1) %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp)
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms,
                           nrow=nvcovpms)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/semsrmod.R"
semsrmod <-
function (X, y, ind, tind, n, k, t., nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    method="nlminb", ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## if w2!=w has been specified, then let w=w2
    w <- w2

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("psi", "rho")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer

    ## modules for likelihood
    Vmat.1 <- function(rho, t.) {
        ## V^(-1) is 'similar' to its 3x3 counterpart,
        ## irrespective of t.:
        ## see Vmat.R in /sparsealgebra
        if(t.==1) {Vmat.1 <- 1} else {
            Vmat.1 <- matrix(0, ncol = t., nrow = t.)
            ## non-extreme diag. elements
            for (i in 2:(t.-1)) Vmat.1[i,i] <- (1-rho^4)/(1-rho^2)
            ## extremes of diagonal
            Vmat.1[1,1] <- Vmat.1[t.,t.] <- 1
            ## bidiagonal elements
            for (j in 1:(t.-1)) Vmat.1[j+1,j] <- -rho
            for (k in 1:(t.-1)) Vmat.1[k,k+1] <- -rho
        }
        return(Vmat.1)
    }
    BB.1 <- function(lambda, w) {
        solve(xprodB(lambda, listw=w))
    }
    invSigma <- function(rholambda, n, t., w) {
        ## retrieve parms
        rho <- rholambda[1]
        lambda <- rholambda[2]
        ## psi not used: here passing 4 parms, but works anyway
        ## because psi is last one
        ## calc inverse
        invVmat <- Vmat.1(rho, t.)
        BB <- xprodB(lambda, w)
        invSigma <- kronecker(invVmat, BB)
        invSigma
    }
    ## likelihood function, both steps included
    ll.c <- function(rholambda, y, X, n, t., w, w2, wy) {
        ## retrieve parms
        rho <- rholambda[1]
        lambda <- rholambda[2]
        ## calc inverse sigma
        sigma.1 <- invSigma(rholambda, n, t., w2)
        ## lag y
        ## do GLS step to get e, s2e
        glsres <- GLSstep(X, y, sigma.1)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        zero <- 0
        uno <- n/2 * log(1 - rho^2)
        tre <- -(n * t.)/2 * log(s2e)
        quattro <- t. * ldetB(lambda, w2)
        cinque <- -1/(2 * s2e) * t(e) %*% sigma.1 %*% e
        const <- -(n * t.)/2 * log(2 * pi)
        ll.c <- const + zero + uno + tre + quattro + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## set bounds for optimizer
    lower.bounds <- c(-0.999, -0.999)
    upper.bounds <- c(0.999, 0.999)

    ## constraints as cA %*% theta + cB >= 0
    ## equivalent to: phi>=0, -1<=(rho, lambda, psi)<=1
    ## NB in maxLik() optimization cannot start at the boundary of the
    ## parameter space !
    cA <- cbind(c(1,-1,rep(0,2)),
               c(rep(0,2), 1, -1))
    cB <- rep(1,4)

    ## generic from here

    ## GLS step function
    GLSstep <- function(X, y, sigma.1) {
        b.hat <- solve(t(X) %*% sigma.1 %*% X,
                       t(X) %*% sigma.1 %*% y)
        ehat <- y - X %*% b.hat
        sigma2ehat <- (t(ehat) %*% sigma.1 %*% ehat)/(n * t.)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## optimization

    ## adaptive scaling
    parscale <- 1/max(myparms0, 0.1)

    if(method=="nlminb") {

        optimum <- nlminb(start = myparms0, objective = ll.c,
                          gradient = NULL, hessian = NULL,
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2,
                          scale = parscale,
                          control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                          lower = lower.bounds, upper = upper.bounds)

        ## log likelihood at optimum (notice inverted sign)
        myll <- -optimum$objective
        ## retrieve optimal parms and H
        myparms <- optimum$par
        myHessian <- fdHess(myparms, function(x) -ll.c(x,
                            y, X, n, t., w, w2))$Hessian

    } else {

        #require(maxLik)

        ## initial values are not allowed to be zero
        maxout<-function(x,a) ifelse(x>a, x, a)
        myparms0 <- maxout(myparms0, 0.01)

        ## invert sign for MAXimization
        ll.c2 <- function(phirholambda, y, X, n, t., w, w2) {
            -ll.c(phirholambda, y, X, n, t., w, w2)
        }

        ## max likelihood
        optimum <- maxLik(logLik = ll.c2,
                          grad = NULL, hess = NULL, start=myparms0,
                          method = method,
                          parscale = parscale,
                          constraints=list(ineqA=cA, ineqB=cB),
                          y = y, X = X, n = n, t. = t., w = w, w2 = w2)

        ## log likelihood at optimum (notice inverted sign)
        myll <- optimum$maximum  # this one MAXimizes
        ## retrieve optimal parms and H
        myparms <- optimum$estimate
        myHessian <- optimum$hessian
    }

    ## one last GLS step at optimal vcov parms
    sigma.1 <- invSigma(myparms, n, t., w)
    beta <- GLSstep(X, y, sigma.1)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(t(X) %*% sigma.1 %*% X)

    ## final vcov(errcomp)
    nvcovpms <- length(nam.errcomp) - 1
    ## error handler here for singular Hessian cases
    covTheta <- try(solve(-myHessian), silent=TRUE)
    if(class(covTheta) == "try-error") {
        covTheta <- matrix(NA, ncol=nvcovpms+1,
                           nrow=nvcovpms+1)
        warning("Hessian matrix is not invertible")
    }
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])
    arcoef <- NULL
    errcomp <- myparms[which(nam.errcomp!="lambda")]
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp[which(nam.errcomp!="lambda")]

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/slag.R"
## spatial lag of object according to listw or matrix

slag <- function(x, listw, maxlag=1, ...) {
    UseMethod("slag")
}

slag.default <- function(x, listw, maxlag=1, index, ...){
    ## needs a vector and a well-specified index
    if(length(x)!=length(index)) {
        stop("Argument and index lengths differ")
    }
    wx <- slagres(x=x, tind=index, listw=listw, maxlag=maxlag, ...)
    return(wx)
}

slag.pseries <- function(x, listw, maxlag=1, ...) {
    ## retrieve index attribute from pseries
    #ind <- attr(x, "index")[,1]
    tind <- attr(x, "index")[,2]

    wx <- slagres(x=x, tind=tind, listw=listw, maxlag=maxlag, ...)

    ## make it a regular pseries
    attr(wx, "index") <- attr(x, "index")
    class(wx) <- c("pseries", class(wx))

    return(wx)
}

slagres <- function(x, tind, listw, maxlag, ...) {
    ## all calculations done inside here
    ## check and if necessary transform
    if(class(listw)[1]=="matrix") {
        listw <- mat2listw(listw, ...)
    }
    ## if maxlag>1 then make higher-order W
    if(maxlag>1) {
        listw <- mat2listw(wlag(listw, maxlag))
    }

    ## unique values
    #unind <- unique(ind)
    tunind <- unique(tind)

    wx <- rep(NA, length(x))

    for(t. in 1:length(tunind)) {
        tpos <- tind==tunind[t.]
        xt <- x[tpos]
        wxt <- lag.listw(listw, xt)
        wx[tpos] <- wxt
    }
    return(wx)
}

wlag<-function(x, maxlag, std=TRUE) {
  ## accepts nb, listw or matrix
  ## returns the proximity matrix of all neighbours up to order=maxlag
  #require(spdep)

  ## convert in neighbours list
  cl1 <- class(x)[1]
  x <- switch(cl1,
              nb={x},
              matrix={mat2listw(x)$neighbours},
              listw={x$neighbours})

  n<-length(x)

  mynb<-nblag(x,maxlag=maxlag)

  mytot<-vector("list",n)

  for(i in 1:n) {
    mytot[[i]]<-mynb[[1]][[i]]
    for(j in 2:maxlag) mytot[[i]]<-c(mytot[[i]],mynb[[j]][[i]])
    ## reorder
    mytot[[i]]<-mytot[[i]][order(mytot[[i]])]
    }

  ## make lagged proximity matrix
  lagmat<-matrix(0,ncol=n,nrow=n)
  for(i in 1:n) lagmat[i,mytot[[i]]]<-1

  ## row-std. if requested
  if(std) lagmat<-lagmat/apply(lagmat,1,sum)

  return(lagmat)
  }





#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sparseBmethods.R"
## sparse matrix version function for B'B
## default is "spam" if fed a listw of style "W" or "S", "naive" if a matrix
##
## usage and computational gains on large example:
#> system.time(b1s<-solveB(lambda=0.2, listw=lwUScw))
#   user  system elapsed
#   0.04    0.00    0.16
#> system.time(b1m<-solveB(lambda=0.2, listw=lwUScw, method="Matrix"))
#   user  system elapsed
#   0.14    0.00    0.55
#> system.time(b1n<-solveB(lambda=0.2, listw=lwUScw, method="naive"))
#   user  system elapsed
#  20.75    0.14   20.91

## needed here, but already in 'splm'??

listw2U_spam <- function(lw){
0.5 * (lw + t(lw))
}

similar.listw_spam <- function(listw)
{
    nbsym <- attr(listw$neighbours, "sym")
    if (is.null(nbsym))
        nbsym <- is.symmetric.nb(listw$neighbours, FALSE)
    if (!nbsym)
        stop("Only symmetric nb can yield similar to symmetric weights")
    if (attr(listw$weights, "mode") == "general")
        if (!attr(listw$weights, "glistsym"))
            stop("General weights must be symmetric")
    n <- length(listw$neighbours)
    if (n < 1)
        stop("non-positive number of entities")
    sww <- as.spam.listw(listw)
    if (listw$style == "W") {
        sd <- attr(listw$weights, "comp")$d
        sd1 <- 1/(sqrt(sd))
        sdd <- diag.spam(sd, n, n)
        sdd1 <- diag.spam(sd1, n, n)
        sww1 <- sdd %*% sww
        res <- sdd1 %*% sww1 %*% sdd1
    }
    else if (listw$style == "S") {
        q <- attr(listw$weights, "comp")$q
        Q <- attr(listw$weights, "comp")$Q
        eff.n <- attr(listw$weights, "comp")$eff.n
        q1 <- 1/(sqrt(q))
        qq <- diag.spam(q, n, n)
        qq1 <- diag.spam(q1, n, n)
        ww0 <- (Q/eff.n) * sww
        ww1 <- qq %*% ww0
        sim0 <- qq1 %*% ww1 %*% qq1
        res <- (eff.n/Q) * sim0
    }
    else stop("Conversion not suitable for this weights style")
    res
}

xprodB <- function(lambda, listw, can.sim=TRUE) {

    ## check if listw or matrix;
    if("listw" %in% class(listw)) {
         ## case listw is 'listw'
         n <- length(listw$weights)
         if (listw$style %in% c("W", "S") & can.sim) {
            csrw <- listw2U_spam(similar.listw_spam(listw))
            similar <- TRUE
         } else {
             csrw <- as.spam.listw(listw)
         }
      } else {
         ## case listw is 'matrix'
         n <- ncol(listw)
         csrw <- as.spam(listw)
     }
     I <- diag.spam(1, n, n)
     B <-  I - lambda * csrw
     xprodB <- t(B) %*% B
     return(xprodB)
}

ldetB <- function(lambda, listw, can.sim=TRUE) {

    ## check if listw or matrix;
    if("listw" %in% class(listw)) {
        ## case listw is 'listw'
        if (listw$style %in% c("W", "S") & can.sim) {
            csrw <- listw2U_spam(similar.listw_spam(listw))
            similar <- TRUE
        }
        else csrw <- as.spam.listw(listw)
        n <- length(listw$weights)
        I <- diag.spam(1, n, n)
        B <- I - lambda * csrw
        J1 <- try(determinant(B, logarithm = TRUE)$modulus, silent = TRUE)
        if (class(J1) == "try-error") {
            ## fall back on standard methods
            ldetB <- log(det(as.matrix(B)))
            warning("Bad result in calculating log(det(B))")
        } else {
            ldetB <- J1
        }
     } else {
         ## case listw is 'matrix'
         n <- ncol(listw)
         ldetB <- log(det(diag(1, n) - lambda * listw))
         #csrw <- as.spam(listw)
     }

     return(ldetB)
}


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/spfeml.R"
spfeml<-function(formula, data=list(), index=NULL, listw, listw2 = NULL, na.action, model = c("lag","error", "sarar"), effects = c('spfe','tpfe','sptpfe'), method="eigen", quiet = TRUE, zero.policy = NULL, interval1 = NULL, interval2 = NULL, trs1 = NULL, trs2 = NULL, tol.solve = 1e-10, control = list(), legacy = FALSE, llprof = NULL, cl = NULL, Hess = FALSE, LeeYu = FALSE, ...){

	  
        # timings <- list()
       # .ptime_start <- proc.time()

model<-match.arg(model)
effects <- match.arg(effects)


if (model == "sarar") con <- list(LAPACK = FALSE,  Imult = 2L, cheb_q = 5L, MC_p = 16L, MC_m=30L, super=FALSE, opt_method = "nlminb", opt_control = list(), pars = NULL, npars = 4L, pre_eig1 = NULL, pre_eig2 = NULL)

else     con <- list(tol.opt = .Machine$double.eps^0.5,  Imult = 2, cheb_q = 5, MC_p = 16, MC_m = 30, super = NULL, spamPivot = "MMD", in_coef = 0.1, type = "MC", correct = TRUE, trunc = TRUE, SE_method = "LU", nrho = 200, interpn = 2000, SElndet = NULL, LU_order = FALSE, pre_eig = NULL)
	


nmsC <- names(con)
con[(namc <- names(control))] <- control
    
    if (length(noNms <- namc[!namc %in% nmsC])) 
            warning("unknown names in control: ", paste(noNms, collapse = ", "))

##    if (is.null(quiet)) # now this has a default in spml(), hence it never is
##	quiet <- !get("verbose", envir = spdep:::.spdepOptions)
##    stopifnot(is.logical(quiet))

	if (is.null(zero.policy))
            zero.policy <- get.ZeroPolicyOption()
        stopifnot(is.logical(zero.policy))
	  
	  
	  ## reorder data if needed
  if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }

  index <- data[,1]
  tindex <- data[,2]

	  ## record call
        ## now passed on from spml() but to be sure:
        if(is.null(cl)) cl <- match.call()

#check the model
# model<-match.arg(model)


#check the effects
effects<-match.arg(effects)


  ## check
  if(dim(data)[[1]]!=length(index)) stop("Non conformable arguments")

  ## reduce X,y to model matrix values (no NAs)
  x<-model.matrix(formula,data=data)
  clnames <- colnames(x)
  rwnames <- rownames(x)

  y<-model.response(model.frame(formula,data=data))
  ## reduce index accordingly
  names(index)<-row.names(data)
  ind<-index[which(names(index)%in%row.names(x))]
  tind<-tindex[which(names(index)%in%row.names(x))]

  ## reorder data by cross-sections, then time
  oo<-order(tind,ind)
  x<-x[oo,]
  y<-y[oo]
  ind<-ind[oo]
  tind<-tind[oo]


  #make sure that the model has no intercept if effects !=pooled
  if (attr(attributes(model.frame(formula,data=data))$terms, "intercept") == 1) {
  	x <- as.matrix(x[,-1])
    colnames(x)<-clnames[-1]
    dimnames(x)[[1]]<-rwnames
    clnames <- clnames[-1]
  }
	x <- as.matrix(x)
    k <- dim(x)[2]
      
    

  ## det. number of groups and df
  N<-length(unique(ind))
  n<-N
  ## det. max. group numerosity
  T<-max(tapply(tind,ind,length))

  ## det. total number of obs. (robust vs. unbalanced panels)
  NT<-length(ind)


  mt<-terms(formula,data=data)
  mf<-lm(formula,data,method="model.frame")#,na.action=na.fail

  na.act<-attr(mf,'na.action')


##checks on listw
  if(is.matrix(listw)) {
    if(dim(listw)[[1]] !=N ) stop("Non conformable spatial weights")
    #require(spdep)
    listw <- mat2listw(listw)
   }
  if (!inherits(listw, "listw"))
        stop("No neighbourhood list")
     
 		can.sim <- FALSE
    if (listw$style %in% c("W", "S")) 
        can.sim <- can.be.simmed(listw)
    if (!is.null(na.act)) {
        subset <- !(1:length(listw$neighbours) %in% na.act)
        listw <- subset(listw, subset, zero.policy = zero.policy)
}
     
###specific checks for the SARAR        
if(model == "sarar"){
	
	 if (is.null(listw2)) 
        listw2 <- listw
     if (!is.null(con$pre_eig1) && is.null(con$pre_eig2)) 
        con$pre_eig2 <- con$pre_eig1
    else if (!inherits(listw2, "listw")) 
        stop("No 2nd neighbourhood list")

# if (is.null(con$fdHess)) con$fdHess <- method != "eigen"
        # stopifnot(is.logical(con$fdHess))

     if (!is.null(con$pars)) {
        stopifnot(is.numeric(con$pars))
    }
    stopifnot(is.integer(con$npars))
    # stopifnot(is.logical(con$fdHess))
    stopifnot(is.logical(con$LAPACK))
    stopifnot(is.logical(con$super))

    can.sim2 <- FALSE
    if (listw2$style %in% c("W", "S")) 
        can.sim2 <- can.be.simmed(listw2)
    if (!is.null(na.act)) {
        subset <- !(1:length(listw2$neighbours) %in% na.act)
        listw2 <- subset(listw2, subset, zero.policy = zero.policy)
    }

	}


switch(model, lag = if (!quiet) cat("\n Spatial Lag Fixed Effects Model \n"),
	    error = if (!quiet) cat("\n Spatial Error Fixed Effects Model\n"),
	    sarar = if (!quiet) cat("\n Spatial SARAR Fixed Effects Model\n"),
	    stop("\nUnknown model type\n"))


  ## check whether the panel is balanced
  balanced<-N*T==NT
  if(!balanced) stop("Estimation method unavailable for unbalanced panels")


	indic<-seq(1,T)
	inde<-as.numeric(rep(indic,each=N)) ####takes the first n observations
	indic1<-seq(1,N)
	inde1<-rep(indic1,T) ####takes observations 1,  n+1, 2n+1...
  ### generates Wy if model=='lag'
  
  
env <- new.env(parent=globalenv())
assign("y",y, envir=env)
assign("x",x, envir=env)
assign("listw",listw, envir=env)
assign("NT",NT, envir=env)
assign("T",T, envir=env)
assign("k",k, envir=env)
assign("n",n, envir=env)


wy<-unlist(tapply(y,inde, function(u) lag.listw(listw,u, zero.policy = zero.policy), simplify=TRUE))
	

#demeaning of the y and x variables depending both on model and effects

if (effects=="tpfe" | effects=="sptpfe"){
	ytms<-tapply(y,inde,mean) ####for each time period takes the mean for the cross section observations
	tpms<-function(q) tapply(q,inde,mean)
	xtms<-apply(x,2,tpms)   ###same thing for the X variable
	ytm<-rep(ytms,each=N) ##generate the NT variables
	xtm<-matrix(,NT,k)
	for (i in 1:k) xtm[,i]<-rep(xtms[,i],each=N)

if (model %in% c("lag", "sarar")) {
		wytms<-tapply(wy,inde,mean) ###same thing for Wy
		wytm<-rep(wytms,each=N)
assign("wytms",wytms, envir=env)
				
}

assign("ytms",ytms, envir=env)
assign("xtms",xtms, envir=env)
	}


if (effects=="spfe" | effects=="sptpfe"){
	ysms<-tapply(y,inde1,mean) ###for each cross-sectional unit takes the mean over the time periods
	spms<-function(q) tapply(q,inde1,mean)
	xsms<-apply(x,2,spms)
	ysm<-rep(ysms,T)
	xsm<-matrix(,NT,k)
	for (i in 1:k) xsm[,i]<-rep(xsms[,i],T)

if (model %in% c("lag", "sarar")){
			wysms<-tapply(wy,inde1,mean)
			wysm<-rep(wysms,T)
			assign("wysms",wysms, envir=env)
			}
			
assign("ysms",ysms, envir=env)
assign("xsms",xsms, envir=env)		
	}
	
	
# if (effects=='pooled'){
	# yt<-y  	###keep the variables with no transformation
	# xt<-x
	# }


if (effects=="tpfe"){ ####generate the demeaned variables for tpfe
	yt<-y-ytm
	xt<-x-xtm
						}


if(effects=="spfe"){ ####generate the demeaned variables for spfe
	yt<-y-ysm
	xt<-x-xsm

	 					}

if (effects=="sptpfe"){ ####generate the demeaned variables for both types of FE
	yt<-y - ysm - ytm + rep(mean(y),NT)
	xmm<-matrix(,NT,(k))
	for (i in 1:(k)) xmm[,i]<-rep(mean(x[,i]),NT)
	xt<-x - xsm - xtm + xmm
								}
								

	wyt<-unlist(tapply(yt,inde, function(u) lag.listw(listw,u), simplify=TRUE))

if(model=="sarar")	{
	w2yt<-unlist(tapply(yt,inde, function(u) lag.listw(listw2,u), simplify=TRUE))
	w2wyt<-unlist(tapply(wyt,inde, function(u) lag.listw(listw2,u), simplify=TRUE))
	
	}
								
								
if 	(model == "error"){
	dm<-function(A) trash<-unlist(tapply(A,inde,function(TT) lag.listw(listw,TT), simplify=TRUE))
   wxt<-apply(xt,2,dm)
   # colnames(wxt)<-paste('Lag.',colnames(x), sep="")
   wx<-apply(x,2,dm)
   # colnames(wx)<-paste('lag.',colnames(x), sep="")
	}

if 	(model == "sarar"){
	dm<-function(A) trash<-unlist(tapply(A,inde,function(TT) lag.listw(listw2,TT), simplify=TRUE))
   wxt<-apply(xt,2,dm)
   # colnames(wxt)<-paste('Lag.',colnames(x), sep="")
   wx<-apply(x,2,dm)
   # colnames(wx)<-paste('lag.',colnames(x), sep="")
	}

# print(clnames)
colnames(xt)<- clnames

	

assign("yt",yt, envir=env)
assign("xt",xt, envir=env)
assign("wyt",wyt, envir=env)
assign("wy",wy, envir=env)


if (model %in% c("error", "sarar")){
	assign("wx",wx, envir=env)
	assign("wxt",wxt, envir=env)
if (model == "sarar")	{
	assign("w2yt",w2yt, envir=env)
	assign("w2wyt",w2wyt, envir=env)
	assign("listw2", listw2, envir = env)
	assign("can.sim2", can.sim2, envir=env)
	assign("similar2", FALSE, envir = env)
	}
	} 

if(model %in% c("lag", "error") ){
	
	assign("compiled_sse", con$compiled_sse, envir=env)	
	assign("f_calls", 0L, envir = env)
    assign("hf_calls", 0L, envir = env)

}



assign("verbose", !quiet, envir = env)
# assign("first_time", TRUE, envir = env)
assign("LAPACK", con$LAPACK, envir = env)
assign("can.sim", can.sim, envir=env)
assign("similar", FALSE, envir = env)
assign("family", "SAR", envir = env)
assign("inde",inde, envir=env)
assign("con", con, envir=env)



    if (!quiet) 
        cat(paste("\nSpatial fixed effects model\n", "Jacobian calculated using "))

if(model == "lag"){
    interval1 <- jacobianSetup(method, env, con, pre_eig = con$pre_eig, trs = trs1, interval = interval1)
    assign("interval1", interval1, envir = env)


    RES<- splaglm(env = env, zero.policy = zero.policy, interval = interval1, con = con, llprof = llprof, tol.solve= tol.solve, Hess = Hess, method = method, LeeYu = LeeYu, effects = effects)
    
    res.eff<-felag(env = env, beta = RES$coeff, sige = RES$s2, effects = effects, method = method, lambda = RES$lambda, legacy = legacy, zero.policy = zero.policy)    

	}

if(model == "sarar"){
	
    interval1 <- jacobianSetup(method, env, con, pre_eig = con$pre_eig1, trs = trs1, interval = interval1, which = 1)
    assign("interval1", interval1, envir = env)
    interval2 <- jacobianSetup(method, env, con, pre_eig = con$pre_eig2, trs = trs2, interval = interval2, which = 2)
    assign("interval2", interval2, envir = env)
    # nm <- paste(method, "set_up", sep = "_")
    # timings[[nm]] <- proc.time() - .ptime_start
    # .ptime_start <- proc.time()
    
      RES<- spsararlm(env = env, zero.policy = zero.policy, con = con, llprof = llprof, tol.solve = tol.solve, Hess = Hess, LeeYu = LeeYu, effects = effects)
  
  
res.eff<-felag(env = env, beta=RES$coeff, sige=RES$s2, effects = effects ,method = method, lambda = RES$lambda, legacy = legacy, zero.policy = zero.policy)    	


		}


if (model=='error'){

    interval1 <- jacobianSetup(method, env, con, pre_eig = con$pre_eig, trs = trs1, interval = interval1)
    assign("interval1", interval1, envir = env)
    # nm <- paste(method, "set_up", sep = "_")
    # timings[[nm]] <- proc.time() - .ptime_start
    # .ptime_start <- proc.time()	

  RES <- sperrorlm(env = env, zero.policy = zero.policy, interval = interval1, Hess = Hess, LeeYu = LeeYu, effects = effects)	
    	res.eff<-feerror(env = env, beta=RES$coeff, sige=RES$s2, effects = effects ,method =method, rho=RES$rho, legacy = legacy)
    	
    }
    
	
	

    ##calculate the R-squared
    yme <- y-mean(y)
    rsqr2 <- crossprod(yme)
    rsqr1 <- crossprod(res.eff[[1]]$res.e)
    res.R2<- 1- rsqr1/rsqr2

	#generate fixed values (from fixed_effect)
	y.hat <- res.eff[[1]]$xhat
	res <- as.numeric(res.eff[[1]]$res.e)
	N.vars<-res.eff$N.vars



	nam.rows <- dimnames(x)[[1]]
	
	
   names(y.hat) <- nam.rows
   names(res) <- nam.rows


	## make model data
   model.data <- data.frame(cbind(y,x))
   dimnames(model.data)[[1]] <- nam.rows




if (model == "lag")   spat.coef<-RES$lambda
if (model == "error") spat.coef<-RES$rho
if (model == "sarar") spat.coef <- c(RES$lambda, RES$rho)


Coeff<-c(spat.coef, RES$coeff)


type <- paste("fixed effects", model)

if (Hess){

	if(model == "lag" ){
   		var<-matrix(0,(ncol(RES$asyvar1)+1),(ncol(RES$asyvar1)+1))
		var[1,1]<-	RES$lambda.se
		var[(2:ncol(var)),(2:ncol(var))]<-RES$asyvar1
	}
	
	if(model == "error" ){
	 	var<-matrix(0,(ncol(RES$asyvar1)+1),(ncol(RES$asyvar1)+1))
    	var[1,1]<-	RES$rho.se
    	var[(2:ncol(var)),(2:ncol(var))]<-RES$asyvar1
	}
	
	if(model == "sarar"){
		var <- matrix(0,(ncol(RES$asyvar1)+2),(ncol(RES$asyvar1)+2))
	    var[1,1] <-	RES$lambda.se
	    var[2,2] <-	RES$rho.se
	    var[(3:ncol(var)),(3:ncol(var))] <- RES$asyvar1
	}
	
} 

else{

if(model == "lag" ){
   var<-matrix(0,(ncol(RES$asyvar1)+1),(ncol(RES$asyvar1)+1))
   var[1,1]<-	RES$lambda.se
   var[(2:ncol(var)),(2:ncol(var))]<-RES$asyvar1
	}

if(model == "error" ){
	var<-matrix(0,(ncol(RES$asyvar1)+1),(ncol(RES$asyvar1)+1))
   var[1,1]<-	RES$rho.se
   var[(2:ncol(var)),(2:ncol(var))]<-RES$asyvar1
	}
	
if(model == "sarar"){
   var<-matrix(0,(ncol(RES$asyvar1)+2),(ncol(RES$asyvar1)+2))
   var[1,1]<-	RES$lambda.se
   var[2,2]<-	RES$rho.se
   var[(3:ncol(var)),(3:ncol(var))]<-RES$asyvar1

	}

}


spmod <- list(coefficients=Coeff, errcomp=NULL,
                vcov = var ,spat.coef=spat.coef,
                vcov.errcomp=NULL,
                residuals=res, fitted.values=y.hat,
                sigma2=RES$s2, type=type, model = model.data,
                call=cl, logLik=RES$ll, method = method, effects=effects, 
                res.eff=res.eff)
                
if (!is.null(na.act)) 
        spmod$na.action <- na.act
                
  class(spmod) <- "splm"
  return(spmod)

	}
       
       
       
       
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/spgm.R"
`spgm` <-
function(formula, data=list(), index=NULL, listw =NULL, listw2 = NULL,
         model=c("within","random"), lag = FALSE, spatial.error=TRUE,
         moments = c("initial", "weights", "fullweights"), endog = NULL, instruments= NULL, lag.instruments = FALSE, verbose = FALSE, method = c("w2sls", "b2sls", "g2sls", "ec2sls"), control = list(), optim.method = "nlminb", pars = NULL){

## translation for uniformity
effects <- switch(match.arg(model), within="fixed", random="random")

if(is.null(listw) && is.null(endog) && !spatial.error) stop("An endogenous variable should be specified")

if(!is.null(listw)){
	
if(!inherits(listw,c("listw", "Matrix", "matrix"))) stop("listw format unknown")
if(inherits(listw,"listw"))  listw <- listw2dgCMatrix(listw)	
if(inherits(listw,"matrix"))  listw <- Matrix(listw)

}

if(!is.null(listw2) && !lag && spatial.error) stop("listw2 can be specified only with sarar")

if(lag && spatial.error){

if(is.null(listw2)) {
	twow <- FALSE		
	listw2 <- listw

	}
else{

if(!inherits(listw2,c("listw", "Matrix", "matrix"))) stop("listw2 format unknown")
if(inherits(listw2,"listw"))  listw2<-listw2dgCMatrix(listw2)	
if(inherits(listw2,"matrix"))  listw2<-Matrix(listw2)

twow <- TRUE
	
}	

}





	
if(model == "within" && attr(terms(formula), "intercept") == 0 ) formula <- as.formula(paste(attr(terms(formula),"variables")[1+attr(terms(formula),"response")], paste(attr(terms(formula),"term.labels"), collapse="+"), sep="~"))

	


cl<-match.call()
if(!spatial.error){
	
	results<-ivsplm(formula = formula, effects = effects, data=data, index = index, endog = endog, instruments = instruments, method = method, lag = lag, listw = listw, lag.instruments = lag.instruments)
	
	results$type <- "lag GM"
	}



else{
	
	
if(!lag) results <- sperrorgm(formula = formula, data = data, index = index, listw = listw, moments = moments, endog = endog, instruments = instruments, verbose = verbose, effects = effects, control = control, lag.instruments = lag.instruments, optim.method = optim.method, pars = pars)
#, initial.GMerror = initial.GMerror

else results <- spsarargm(formula = formula, data = data, index = index, listw = listw, listw2 = listw2,  moments = moments, lag = lag, endog = endog, instruments = instruments, verbose = verbose, effects = effects, control = control, lag.instruments = lag.instruments, optim.method = optim.method, pars = pars, twow = twow)

	}

results$call <- cl
results$ef.sph<- effects
results$legacy <- c(lag, spatial.error)
results$endog <- endog
results

}




panel.transformations <- function(arg1, indicator, type=c("within","between","both")){

	type<-match.arg(type)
	num <- length(indicator)
	den <- length(unique(indicator))
	tmp <- num/den  
	# print(tmp)
 	if(!is.matrix(arg1)) arg1<-as.matrix(arg1)
 	
spms<-function(q) tapply(q,indicator,mean)

 switch(type, between = {

	arg1_b<-matrix(apply(arg1,2,spms), den, ncol(arg1))
	out<-arg1_b
		
		}, 
		within ={			

	arg1_b<-matrix(apply(arg1,2,spms), den, ncol(arg1))
	 # print(arg1_b)
	arg1_bnt<- apply(arg1_b, 2, function(bb) rep(bb,  tmp))             
	# print(arg1_bnt)
	arg1_w	<- arg1 - arg1_bnt
	out<-arg1_w
		
			}, 			
			both = {
				
	arg1_b<-matrix(apply(arg1,2,spms), den, ncol(arg1))
	arg1_bnt<- apply(arg1_b, 2, function(bb) rep(bb, tmp ))  
	arg1_w	<- arg1 - arg1_bnt
	out<-list(arg1_w, arg1_b)			
				
				}		
		)	

out


	}


spgm.tsls <- function(y, yend, X, Zinst, Hinst= NULL, instr = FALSE){

	yend<-as.matrix(yend)
if (instr) H <- Hinst	
else    H <- cbind(X, Zinst)
   Z <- cbind(yend, X)
   Znames<- colnames(Z) 
	 yendp<-matrix(,nrow(yend), ncol(yend))
for(i in 1:ncol(yend))	yendp[,i] <- fitted.values(lm(yend[,i] ~ H-1  ))
    Zp <- cbind(yendp,X)
    model.fit<-lm(y~Zp-1)
    biv <- coefficients(model.fit)
readout<- which(is.na(biv))

if(any(is.na(biv)))  yp <- as.matrix(Z[,-which(is.na(biv))]) %*% biv[-which(is.na(biv))]
else yp <- Z %*% biv



        ehat <- y-yp
        sse <- c(crossprod(ehat, ehat))
        df <- model.fit$df.residual
        s2 <- sse/df
        
if(any(is.na(biv)))   Zp<-as.matrix(Zp)[,-which(is.na(biv))]  


ZpZi<-solve(crossprod(Zp))   

         varb<-ZpZi *  s2



names(biv)<-Znames

if(any(is.na(biv))) biv<-biv[-which(is.na(biv))] 
else	biv<-biv



        result <- list(coefficients = biv, var = varb, sse = sse, 
            residuals = as.numeric(ehat), df = df, Zp = Zp, readout = readout)
    
    result
}



sperrorgm<-function(formula, data = list(), index = NULL, listw , moments = c("initial","weights","fullweights"), endog = NULL, instruments = NULL, verbose = FALSE, effects = c("fixed","random"), control = list(), lag.instruments = lag.instruments, optim.method = optim.method, pars = pars ){

effects<-match.arg(effects)
moments<-match.arg(moments)
indes<-index

 if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }
  
  index <- data[,1]
  tindex <- data[,2]

  names(index)<-row.names(data)
  ind <-index[which(names(index)%in%row.names(data))]
  tind<-tindex[which(names(index)%in%row.names(data))]
   spord <- order(tind, ind)
   # print(spord)
   data <-  data[spord,]


  cl <- match.call()
  if(dim(data)[[1]]!=length(index)) stop("Non conformable arguments")


    mt <- terms(formula, data = data)
    mf <- lm(formula, data, na.action = na.fail, method = "model.frame")

    y <- model.extract(mf, "response")
    x <- model.matrix(mt, mf)


   
  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)

  
  balanced<-N*T==NT
if(!balanced) stop("Estimation method unavailable for unbalanced panels")

I_T <- Diagonal(T)
Ws <- kronecker(I_T, listw)


if(!is.null(endog)){
	endog <- as.matrix(lm(endog, data, na.action = na.fail, method = "model.frame"))
if(is.null(instruments)) stop("No instruments specified  for the additional variable")
else instruments <- as.matrix(lm(instruments, data, na.action = na.fail, method = "model.frame"))	
	}



indic <- rep(1:N,T)

transx <- panel.transformations(x, indic, type= "both")
Xbetween<-transx[[2]]
Xwithin<-transx[[1]]
Xbetween <- as.matrix(Xbetween)
Xwithin <- as.matrix(Xwithin)
del<-which(diag(var(as.matrix(Xwithin)))==0)
if (colnames(x)[1] == "(Intercept)") Xbetween <- Xbetween[,-1]
delb <- which(diag(var(as.matrix(Xbetween)))==0)
if(length(delb)==0) Xbetween<-Xbetween
else Xbetween<-Xbetween[,-delb]
Xbetween<-cbind(1,Xbetween)

switch(effects, 

	fixed = {

if(is.null(endog)){
ywithin <- panel.transformations(y, indic, type= "within")	
 result <- lm(ywithin ~ Xwithin[,-del] -1)
}	

else 	result <- ivplm.w2sls(Y = y, X =x, H = instruments, endog = endog, lag = FALSE, listw = Ws, lag.instruments = lag.instruments, T, N, NT)

res <- as.matrix(residuals(result)) 



Gg<-fswithin(Ws, res, N, T)

if(is.null(pars)) {
	
    wres <- as.matrix(Ws %*% res)
    r.init <- solve(crossprod(res),crossprod(res,wres))
if(is.null(endog))	v.init <- crossprod(res)/NT	
else    	        v.init <- result$sigmav
	pars <- c(r.init, v.init)	
}

if (optim.method == "nlminb") estim1 <- nlminb(pars, arg, v = Gg, verbose = verbose, control = control, lower=c(-0.999,0), upper=c(0.999, Inf))

else estim1 <- optim(pars, arg, v = Gg, verbose = verbose, control = control, method = optim.method)

	finrho=estim1$par[1]
	 finsigmaV=estim1$par[2]
	# finsigmaV = result$sigmav
     # print(c(finrho,finsigmaV))	

   wy <- as.matrix(Ws %*% y)
   yt <- y-finrho*wy
   xl<- as.matrix(Ws %*%  x)
   xt <- x-finrho*xl


	yf<-panel.transformations(yt,indic, type= "within")
    xf<-panel.transformations(xt,indic, type= "within")
	xf<-xf[,-del]
	xf<-as.matrix(xf)
	colnames(xf)<-colnames(x)[-del]
	wxf <- as.matrix(Ws %*% xf)

if (is.null(endog)){

result<-lm(as.matrix(yf)~as.matrix(xf)-1)
vcov<-vcov(result)
betaGLS <- coefficients(result)

	names(betaGLS)<-colnames(xf)
  errcomp<-rbind(finrho,finsigmaV)
  nam.errcomp <- c("rho","sigma^2_v")
    rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
   model.data <- data.frame(cbind(y,x[,-1]))

  type <- "fixed effects GM"
    spmod <- list(coefficients= betaGLS, errcomp=errcomp,
                vcov=vcov, vcov.errcomp=NULL,
                residuals=residuals(result), fitted.values=(y-as.vector(residuals(result))),
                sigma2=crossprod(residuals(result))/result$df.residual, type=type, rho=errcomp, model=model.data, logLik=NULL)
  class(spmod) <- "splm"
  return(spmod)

	
	}

else{
	
   endogl <- as.matrix(Ws %*% endog)
   endogt <- endog - finrho* endogl

endogf<-panel.transformations(endogt,indic, type= "within")

  instwithin <- result$Hwithin
 # instwithin<-cbind(xf, wxf, instwithin)
 instwithin<-cbind(xf, instwithin)
  model.fit <- spgm.tsls(yf,endogf, xf, Hinst = instwithin, instr  = T )  
  betaGLS <- model.fit$coefficients 
 # print(betaGLS)


  Zp<-model.fit$Zp
  Z<-cbind(endog,x[,-del])
  fv<-as.matrix(Z) %*% as.matrix(betaGLS)
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT

  nam.beta <- c(colnames(endog), colnames(x)[-del])
  names(betaGLS) <- nam.beta
  errcomp<-rbind(finrho,finsigmaV)
  nam.errcomp <- c("rho","sigma^2_v")
   model.data <- data.frame(cbind(y,x[,-1]))

  type <- "fixed effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=  errcomp,
                vcov=covbeta, vcov.errcomp=NULL,
                residuals=as.vector(egls), fitted.values=fv,
                sigma2=SGLS, type=type, rho=errcomp[1], model=model.data, logLik=NULL)
  class(spmod) <- "splm"
  return(spmod)
	
	
	}
 return(spmod)
		},
		
	random = {
		
if(is.null(endog))	{

result<-lm(y~x-1) 

res<-as.matrix(residuals(result))
Gg<-fs(Ws,res,N,T)

## parameter initial values 
 if(is.null(pars)) {
    wres <- as.matrix(Ws %*% res)
    r.init <- solve(crossprod(res),crossprod(res,wres))
	v.init <- crossprod(res)/NT	
	pars <- c(r.init, v.init)	
}


 if (optim.method == "nlminb") estim1 <- nlminb(pars, arg, v = Gg, verbose = verbose, control = control, lower=c(-0.999,0), upper=c(0.999,Inf))
else estim1 <- optim(pars, arg, v = Gg, verbose = verbose, control = control, method = optim.method)

urub<-res- estim1$par[1]*Gg$ub
Q1urQ1ub<-Gg$Q1u - estim1$par[1]*Gg$Q1ub
S1 <- crossprod(urub, Q1urQ1ub)/N

switch(moments, 
	  
	  initial = {
	  	
	finrho=estim1$par[1]
	finsigmaV=estim1$par[2]
	finsigma1=S1
	
    }, 
    
    weights = {
    	
  	   Ggw<-pw(bigG=Gg$bigG, smallg=Gg$smallg, Q1u=Gg$Q1u,Q1ub=Gg$Q1ub,Q1ubb=Gg$Q1ubb, u=res, ub=Gg$ub,ubb=Gg$ubb,N=N, TR=Gg$TR)
      pars2<-c(estim1$par[1],estim1$par[2],S1)

 if (optim.method == "nlminb") estim2 <- nlminb(pars2, arg1, v = Ggw,T=T,ss=estim1$par[2] ,SS=S1, verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))
else      estim2 <- optim(pars2, arg1, v = Ggw,T=T,ss=estim1$par[2] ,SS=S1, verbose = verbose, control = control, method = optim.method)

	finrho=estim2$par[1]
	finsigmaV=estim2$par[2]
	finsigma1=estim2$par[3]

    }, 
    
    fullweights = {

	   Ggw<-pw(bigG=Gg$bigG, smallg=Gg$smallg, Q1u=Gg$Q1u,Q1ub=Gg$Q1ub,Q1ubb=Gg$Q1ubb, u=res, ub=Gg$ub,ubb=Gg$ubb,N=N, TR=Gg$TR)
      weights<-tw(listw, N)
      pars2<-c(estim1$par[1],estim1$par[2],S1)

 if (optim.method == "nlminb") estim3 <-nlminb(pars2, arg2, v = Ggw, T=T,ss=estim1$par[2] ,SS=S1, TW=weights$TW, verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))
else   estim3 <-optim(pars2, arg2, v = Ggw, T=T,ss=estim1$par[2] ,SS=S1, TW=weights$TW, verbose = verbose, control = control, method = optim.method)
      
	finrho=estim3$par[1]
	finsigmaV=estim3$par[2]
	finsigma1=estim3$par[3]


	
		}, 
		stop("...\nUnknown method\n"))
	
	
	}
else{

		result1<-ivplm.w2sls(Y = y,X =x, H = instruments, endog = endog,  lag = FALSE, listw = Ws, lag.instruments = lag.instruments, T, N, NT)

		result2<-ivplm.b2sls(Y = y,X =x, H = instruments, endog = endog,  lag = FALSE, listw = Ws, lag.instruments = lag.instruments, T, N, NT)

res1<-as.matrix(as.numeric(residuals(result1)))
res2<-as.matrix(as.numeric(residuals(result2)))

Gg<-fswithin(Ws,res1,N,T)

if(is.null(pars)) {
    wres <- as.matrix(Ws %*% res1)
    r.init <- solve(crossprod(res1),crossprod(res1,wres))
	v.init <- result1$sigmav	
	pars <- c(r.init, v.init)	
}


if (optim.method == "nlminb")  estim1 <- nlminb(pars, arg, v = Gg, verbose = verbose, control = control, lower=c(-0.999, 0), upper=c(0.999,Inf))

else estim1 <- optim(pars, arg, v = Gg, verbose = verbose, control = control, method = optim.method)


Wres2 <- as.matrix(listw %*% res2)
urhoWu<-res2 - estim1$par[1] * Wres2
finsigma1<-crossprod(urhoWu)/N


switch(moments, 
	  
	  initial = {
	  	
	finrho=estim1$par[1]
	finsigmaV=estim1$par[2]
	finsigma1=finsigma1
	
    }, 
    
    weights = {
    	
    	Ggw<-pwbetween(bigG=Gg$bigG, smallg=Gg$smallg, u=res2, N=N, T=T, TR=Gg$TR, listw = listw)
      pars2<-c(estim1$par[1],estim1$par[2],finsigma1)

 if (optim.method == "nlminb")  estim2 <- nlminb(pars2, arg1, v = Ggw,T=T, ss= estim1$par[2], SS=finsigma1 , verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))

else    estim2 <- optim(pars2, arg1, v = Ggw, T=T, ss= estim1$par[2], SS=finsigma1 , verbose = verbose, control = control, method = optim.method)
      
	finrho=estim2$par[1]
	finsigmaV=estim2$par[2]
	finsigma1=estim2$par[3]

    }, 
    
    fullweights = {

	   Ggw<-pwbetween(bigG=Gg$bigG, smallg=Gg$smallg, u=res2, N=N,T=T, TR=Gg$TR, listw = listw)
      weights<-tw(listw, N)
      pars2<-c(estim1$par[1],estim1$par[2],finsigma1)

 if (optim.method == "nlminb") estim3 <-nlminb(pars2, arg2, v = Ggw, T = T,ss= estim1$par[2], SS=finsigma1 , TW = weights$TW, verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))
 
else    estim3 <-optim(pars2, arg2, v = Ggw, T = T,ss= estim1$par[2], SS=finsigma1 , TW = weights$TW, verbose = verbose, control = control, method = optim.method)

	finrho=estim3$par[1]
	finsigmaV=estim3$par[2]
	finsigma1=estim3$par[3]


	
		}, 
		stop("...\nUnknown method\n"))
	}

theta<- 1-(sqrt(finsigmaV)/sqrt(finsigma1))	
wy <- as.matrix(Ws %*% y)
yt <- y-finrho*wy
xl<- as.matrix(Ws %*% x)
xt <- x-finrho*xl

 
ytmt<-tapply(yt, indic, mean)
ytNT<-rep(ytmt, T)
yf<-(yt - theta*ytNT)

dm1<- function(A) rep(unlist(tapply(A, indic, mean, simplify=TRUE)), T)
xtNT<-apply(xt,2,dm1)
xf<-(xt - as.numeric(theta)*xtNT)
wxf <- as.matrix(Ws %*% xf)

if (is.null(endog)){
	
  xfpxf<-crossprod(xf)
  xfpxfi<-solve(xfpxf)
  betaGLS<-xfpxfi%*%crossprod(xf,yf) 
  betaGLS<- as.numeric(betaGLS)
#print(betaGLS)  
  fv<-as.vector(x %*% betaGLS)
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*xfpxf/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT

  errcomp<-rbind(finrho,finsigmaV,finsigma1,theta)
  nam.beta <- dimnames(x)[[2]]
  nam.errcomp <- c("rho","sigma^2_v",'sigma^2_1',"theta")
  names(betaGLS) <- nam.beta
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))
sigma2 <- SGLS
  type <- "random effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=errcomp,
                vcov=covbeta, vcov.errcomp=NULL,
                residuals=as.vector(egls), fitted.values=fv,
                sigma2=sigma2,type=type, rho=errcomp, model=model.data,
                call=cl, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)

	}

else{
	
	endogl<- as.matrix(Ws %*% endog)
   endogt <- endog - finrho*endogl

endogt<-as.matrix(endogt)
endogtNT<-apply(endogt,2,dm1)
endogf<-(endogt - as.numeric(theta)*endogtNT)

# instt<-panel.transformations(instruments,indic, type= "both")
# instbetween<-instt[[2]]
# instwithin<-instt[[1]]
instbetween <- result2$Hbetween
instwithin <- result1$Hwithin

instbetweennt<-matrix(,NT,ncol(instbetween))
for (i in 1:ncol(instbetween)) instbetweennt[,i]<-rep(instbetween[,i], T)

 Zf<-cbind(endog,x)
 # Hins<-cbind(xf,wxf, instwithin,instbetweennt)
 Hins<-cbind(xf, instwithin,instbetweennt)
  model.fit <- spgm.tsls(yf,endogf,xf, Hinst = Hins, instr  = T)  
  betaGLS <- model.fit$coefficients 



  Zp<-model.fit$Zp
  fv<-as.matrix(Zf) %*% as.matrix(betaGLS)
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT

  errcomp<-rbind(finrho,finsigmaV,finsigma1,theta)
  nam.beta <- colnames(Zf)
  names(betaGLS) <- nam.beta
  nam.errcomp <- c("rho","sigma^2_v",'sigma^2_1',"theta")
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))
sigma2 <- SGLS
  type <- "random effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=errcomp,
                vcov=covbeta, vcov.errcomp=NULL,
                residuals=as.vector(egls), fitted.values=fv,
                sigma2=sigma2,type=type, rho=errcomp, model=model.data,
                call=cl, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)

}

	
    }, 

    
    stop("...\nUnknown method\n"))
	
	
return(spmod)	
	
	}




# Hmatrices <- function(Ws, x, Xwithin, Xbetween, del, delb, NT){
	
# WX <- as.matrix(Ws %*% x)
# WWX <-as.matrix(Ws %*% WX)
# WX <- WX[,-del]
# WWX <- WWX[,-del]
# HX <- cbind(WX, WWX)

# WXwithin <- as.matrix(Ws %*% Xwithin)
# WWXwithin <- as.matrix(Ws %*% WXwithin)
# WXwithin<-WXwithin[,-del]
# WWXwithin<-WWXwithin[,-del]


# # spms <- function(q) tapply(q, indic, mean)

# Xbetweennt<-matrix(,NT, ncol(Xbetween))
# for (i in 1:ncol(Xbetween)) Xbetweennt[,i]<-rep(Xbetween[,i], T)
# if (colnames(x)[1] == "(Intercept)") Xbetweennt <- Xbetweennt[,-1]


# WXbetween <- as.matrix(Ws %*% Xbetweennt)
# if(length(delb)==0) WXbetween<-WXbetween
# else WXbetween<-WXbetween[,-delb]
# WWXbetween <- as.matrix(Ws %*% WXbetween)
# if(length(delb)==0) WWXbetween<-WWXbetween
# else WWXbetween<-WWXbetween[,-delb]

# Hwithin<-cbind(Xwithin[,-del],WXwithin, WWXwithin)
# Hbetween<-cbind(1, Xbetweennt,WXbetween, WWXbetween)
# Hgls<-cbind(1, Hwithin, Hbetween[,-1])

# Hmatr <- list(Hwithin, Hbetween, Hgls)

# }


spsarargm<-function(formula, data = list(), index = NULL, listw, listw2 = NULL, moments = c("initial", "weights", "fullweights"), lag= FALSE, endog = NULL, instruments = NULL, verbose = FALSE, effects = c("fixed","random"), control = list(), lag.instruments = lag.instruments, optim.method = optim.method, pars = pars, twow ){


effects<-match.arg(effects)
moments<-match.arg(moments)
indes<-index

 if(!is.null(index)) {
    #require(plm)
    data <- plm.data(data, index)
    }
  
  index <- data[,1]
  tindex <- data[,2]

  names(index)<-row.names(data)
  ind <-index[which(names(index)%in%row.names(data))]
  tind<-tindex[which(names(index)%in%row.names(data))]
   spord <- order(tind, ind)
   # print(spord)
   data <-  data[spord,]


  cl <- match.call()
  if(dim(data)[[1]]!=length(index)) stop("Non conformable arguments")


    mt <- terms(formula, data = data)
    mf <- lm(formula, data, na.action = na.fail, method = "model.frame")

    y <- model.extract(mf, "response")
    x <- model.matrix(mt, mf)
    namesx <- colnames(x)
    
  N<-length(unique(ind))
  k<-dim(x)[[2]]
  T<-max(tapply(x[,1],ind,length))
  NT<-length(ind)
  indic <- rep(1:N,T)

  balanced<-N*T==NT
if(!balanced) stop("Estimation method unavailable for unbalanced panels")


I_T <- Diagonal(T)
Ws <- kronecker(I_T, listw)

if(twow) Ws2 <- kronecker(I_T, listw2)
else Ws2 <-Ws

listw2nn <- Ws2[1:N, 1:N]

if(!is.null(endog)){
	endog <- as.matrix(lm(endog, data, na.action = na.fail, method = "model.frame"))
if(is.null(instruments)) stop("No instruments specified  for the additional variable")
else instruments <- as.matrix(lm(instruments, data, na.action = na.fail, method = "model.frame"))	
	}



##transform X	
transx<-panel.transformations(x, indic, type= "both")
Xbetween<-transx[[2]]
Xwithin<-transx[[1]]
Xbetween <- as.matrix(Xbetween)
Xwithin <- as.matrix(Xwithin)
del<-which(diag(var(as.matrix(Xwithin)))==0)
if (namesx[1] == "(Intercept)") Xbetween <- Xbetween[,-1]
delb<-which(diag(var(as.matrix(Xbetween)))==0)
if(length(delb)==0) Xbetween<-Xbetween
else Xbetween<-Xbetween[,-delb]
Xbetween<-cbind(1,Xbetween)
deltot<-c(del,delb)
Xbetweennt<-matrix(,NT, ncol(Xbetween))
for (i in 1:ncol(Xbetween)) Xbetweennt[,i]<-rep(Xbetween[,i], T)

switch(effects, 

	fixed = {
		
if(is.null(endog)) result<-ivplm.w2sls(Y = y,X = x, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)

else 	result<-ivplm.w2sls(Y = y, X = x, H = instruments, endog = endog, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)


# print(result$coefficients)
res <- as.matrix(as.numeric(residuals(result)))
Hwithin <- cbind(Xwithin[,-del], result$Hwithin)


Gg<-fswithin(Ws2,res,N,T)

if(is.null(pars)) {
	
    wres <- as.matrix(Ws2 %*% res)
    r.init <- solve(crossprod(res),crossprod(res,wres))
	v.init <- crossprod(res)/NT	
	pars <- c(r.init, v.init)	
}




if (optim.method == "nlminb")  estim1 <- nlminb(pars, arg, v = Gg, verbose = verbose,  lower=c(-0.999,0), upper=c(0.9999,Inf))

else estim1 <- optim(pars, arg, v = Gg, verbose = verbose, control = control, method = optim.method)

finrho<-estim1$par[1]
finsigmaV<-estim1$par[2]
# print(c(finrho,finsigmaV))

   wy <- as.matrix(Ws2 %*% y)
   yt <- y-finrho*wy
   xl <- as.matrix(Ws2 %*%  x)
   xt <- x-finrho*xl
   
	wwy <- as.matrix(Ws2 %*% wy)
	wyt<-wy-finrho*wwy


	yf<-panel.transformations(yt,indic, type= "within")
   xf<-panel.transformations(xt,indic, type= "within")
   wyf<-panel.transformations(wyt,indic, type= "within")
	xf<-xf[,-del]
	xf<-as.matrix(xf)
	colnames(xf)<- namesx[-del]
	# wxf <- as.matrix(Ws %*% xf)

	
if (is.null(endog)){
	

model.fit <- spgm.tsls(yf, wyf, xf, Hinst =  Hwithin, instr = TRUE)  	
	  betaGLS <- model.fit$coefficients 
	  names(betaGLS)[1]<-"lambda"
# print(length(betaGLS))
  Zp <- model.fit$Zp
  Z<-cbind(wy,x[,-del])
  # print(dim(Z))
  fv<-as.matrix(Z) %*% betaGLS
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT



  errcomp<-rbind(finrho,finsigmaV)
  nam.errcomp <- c("rho","sigma^2_v")
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))

  type <- "fixed effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=errcomp,
                vcov=covbeta, vcov.errcomp=NULL,
                residuals=as.numeric(egls), fitted.values=fv,
                sigma2=SGLS,type=type, rho=errcomp, model=model.data, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)

	}

else{
	
	endogl<- as.matrix(Ws2 %*% endog)
   endogt <- endog - finrho*endogl

	endogf<-panel.transformations(endogt,indic, type= "within")

  yend<-cbind(endogf, wyf)
  
model.fit <- spgm.tsls(yf, yend, xf, Hinst = Hwithin, instr = TRUE)  	
	  betaGLS <- model.fit$coefficients 
	  names(betaGLS)[ncol(endog)+1]<-"lambda"
#print(betaGLS)

  Zp<-model.fit$Zp
  Z<-cbind(endog, wy, x[,-del])
  fv<-as.matrix(Z) %*% betaGLS
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT
  
  errcomp<-rbind(finrho,finsigmaV)
  nam.errcomp <- c("rho","sigma^2_v")
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))

  type <- "fixed effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=  errcomp,
                vcov=  covbeta, vcov.errcomp=NULL,
                residuals=as.numeric(egls), fitted.values=fv,
                sigma2=SGLS,type=type, rho=errcomp, model=model.data, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)
	
	
	}

		},
		
	random = {

if(is.null(endog)){

	result1<-ivplm.w2sls(Y = y,X =x, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)
	result2<-ivplm.b2sls(Y = y,X =x, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)

#		fsig1<-result$sigma1
#		fsigv<-result$sigmav
	}
	
	else{
		result1<-ivplm.w2sls(Y = y,X =x, H = instruments, endog = endog, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)
		result2<-ivplm.b2sls(Y = y,X =x, H = instruments, endog = endog, lag = TRUE, listw = Ws, listw2 = Ws2, twow = twow, lag.instruments = lag.instruments, T = T, N = N, NT = NT)

#		fsig1<-result$sigma1
#		fsigv<-result$sigmav		
		}

Hwithin <- result1$Hwithin
Hbetween <- result2$Hbetween
Hbetweennt<-matrix(,NT, ncol(Hbetween))
for (i in 1:ncol(Hbetween)) Hbetweennt[,i]<-rep(Hbetween[,i], T)

res1<-as.matrix(as.numeric(residuals(result1)))
res2<-as.matrix(as.numeric(residuals(result2)))

Gg<-fswithin(Ws2, res1, N, T)

if(is.null(pars)) {
    wres <- as.matrix(Ws2 %*% res1)
    r.init <- solve(crossprod(res1),crossprod(res1,wres))
	v.init <- crossprod(res1)/NT	
	pars <- c(r.init, v.init)	
}


if (optim.method == "nlminb")  estim1 <- nlminb(pars, arg, v = Gg, verbose = verbose, control = control, lower=c(-0.999,0), upper=c(0.999,Inf))

else estim1 <- optim(pars, arg, v = Gg, verbose = verbose, method = optim.method)

Wres2 <- as.matrix(listw2nn %*% res2)
urhoWu<-res2 - estim1$par[1] * Wres2
finsigma1<-crossprod(urhoWu)/N


switch(moments, 
	  
	  initial = {
	  	
	finrho=estim1$par[1]
	finsigmaV=estim1$par[2]
	finsigma1=finsigma1
	
    }, 
    
    weights = {
    	
    	Ggw<-pwbetween(bigG=Gg$bigG, smallg=Gg$smallg, u=res2, N=N, T=T, TR=Gg$TR, listw=listw2nn)
      pars2<-c(estim1$par[1],estim1$par[2],finsigma1)

if (optim.method == "nlminb")  estim2 <- nlminb(pars2, arg1, v = Ggw,T=T, ss= estim1$par[2], SS=finsigma1 ,verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))

else      estim2 <- optim(pars2, arg1, v = Ggw, T=T, ss= estim1$par[2], SS=finsigma1 ,verbose = verbose, method = optim.method)
      
      
	finrho=estim2$par[1]
	finsigmaV=estim2$par[2]
	finsigma1=estim2$par[3]

    }, 
    
    fullweights = {

	   Ggw<-pwbetween(bigG=Gg$bigG, smallg=Gg$smallg, u=res2, N=N,T=T, TR=Gg$TR, listw = listw2nn)
      weights<-tw(W=listw2nn, N)
      pars2<-c(estim1$par[1],estim1$par[2],finsigma1)
     # 
if(optim.method == "nlminb")   estim3 <-nlminb(pars2, arg2, v = Ggw, T = T, ss= estim1$par[2], SS=finsigma1 ,TW = weights$TW, verbose = verbose, control = control, lower=c(-0.999,0,0), upper=c(0.999,Inf,Inf))
else estim3 <-optim(pars2, arg2, v = Ggw, T = T, ss= estim1$par[2], SS=finsigma1 ,TW = weights$TW, verbose = verbose, method = optim.method)

	finrho=estim3$par[1]
	finsigmaV=estim3$par[2]
	finsigma1=estim3$par[3]


	
		}, 
		stop("...\nUnknown method\n"))



 theta<- 1-(sqrt(finsigmaV)/sqrt(finsigma1))
 
	wy<- as.matrix(Ws2 %*% y)
   yt <- y-finrho*wy
   xl<- as.matrix(Ws2 %*% x)
   xt <- x-finrho*xl
   wwy<- as.matrix(Ws2 %*% wy)
	wyt<-wy - finrho*wwy

	
	

  ytmt<-tapply(yt, indic, mean)
  ytNT<-rep(ytmt, T)
  yf<-(yt - theta*ytNT)
  
  dm1<- function(A) rep(unlist(tapply(A, indic, mean, simplify=TRUE)), T)
  xtNT<-apply(xt,2,dm1)
  xf<-(xt - as.numeric(theta)*xtNT)
  
  wytmt<-tapply(wyt, indic, mean)
  wytNT<-rep(wytmt, T)  
  wyf<-wyt - as.numeric(theta)*wytNT

Hgls <- cbind(1, Xwithin,Xbetweennt, Hwithin, Hbetweennt)	

if (is.null(endog)){
model.fit <- spgm.tsls(yf, wyf, xf,  Hgls)  	
	  betaGLS <- model.fit$coefficients 
names(betaGLS)[1]<-"lambda"
#print(betaGLS)

  Zp<-model.fit$Zp
  Z<-cbind(wy,x)
  fv<-as.matrix(Z) %*% as.matrix(betaGLS)
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT
	

  errcomp<-rbind(finrho,finsigmaV,finsigma1,theta)
  nam.errcomp <- c("rho","sigma^2_v",'sigma^2_1',"theta")
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))

  type <- "random effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=errcomp,
                vcov=covbeta, vcov.errcomp=NULL,
                residuals=as.numeric(egls), fitted.values=fv,
                sigma2=SGLS,type=type, rho=errcomp, model=model.data, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)

	}

else{
	
  endogl<-as.matrix(Ws2 %*% endog)
  endogt <- endog - finrho*endogl

  endogtNT<-apply(as.matrix(endogt), 2, dm1)
  endogf<-(endogt - as.numeric(theta)*endogtNT)


  yend<-cbind(endogf, wyf)  
  
model.fit <- spgm.tsls(yf, yend, xf,  Hgls)  	
	  betaGLS <- model.fit$coefficients 
names(betaGLS)[ncol(as.matrix(endog)) + 1 ]<-"lambda"
#print(betaGLS)

  Zp<-model.fit$Zp
  Z<-cbind(endog, wy,x)
  fv<-as.matrix(Z) %*% as.matrix(betaGLS)
  egls<-y - fv
  SGLS<-sum(egls^2)/(N-1)
  xfpxfNT<-(1/NT)*crossprod(Zp)/finsigmaV
  PSI<-solve(xfpxfNT)
  covbeta<-PSI/NT
  

  errcomp<-rbind(finrho,finsigmaV,finsigma1,theta)
  nam.errcomp <- c("rho","sigma^2_v",'sigma^2_1',"theta")
  rownames(errcomp) <- nam.errcomp
  colnames(errcomp)<-"Estimate"
model.data <- data.frame(cbind(y,x))

  type <- "random effects GM"
    spmod <- list(coefficients=betaGLS, errcomp=  errcomp,
                vcov=  covbeta, vcov.errcomp=NULL,
                residuals=as.numeric(egls), fitted.values=fv,
                sigma2=SGLS,type=type, rho=errcomp, model=model.data, logLik=NULL, coy=yt, cox=xt, rhs=k)
  class(spmod) <- "splm"
  return(spmod)

	}
		}, 
		stop("...\nUnknown method\n"))	
	
	
  return(spmod)
  

	}
	
	





	
	
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sphtest.R"

sphtest <- function (x, ...)
{
    UseMethod("sphtest")
}

sphtest.formula <- function (x, data, index = NULL, listw, spatial.model = c("lag", "error", "sarar"), method = c("ML", "GM"), errors = c("KKP", "BSK"),...)
{
 ## performs a Hausman test of a FE model with spatial lag or error
 ## against "alternative" with same spatial specification

    switch(match.arg(spatial.model),
    lag = {
    	lag = TRUE
    	spatial.error = FALSE
    	},
    error = {
    	lag = FALSE
    	spatial.error = TRUE
    	},
    sarar = {
    	lag = TRUE
    	spatial.error = TRUE
    	},
    	
    )

errors <- match.arg(errors)

    x0 <- update(x, .~.-1)

    method <- switch(match.arg(method), 

    ML = {
    	
    femod <- spml(x, data = data, index = index, listw = listw, lag = lag, spatial.error = spatial.error, model = "within", errors = errors)

    remod <- spml(x, data = data, index = index, listw = listw, lag = lag, spatial.error = spatial.error, model = "random", errors = errors)
  	
    	},
    	
    GM = {
    	
  femod <- spgm(x, data = data, index = index, listw = listw, lag = lag, spatial.error = spatial.error, model = "within", moments = "fullweights")
  
  remod <- spgm(x, data = data, index = index, listw = listw, lag = lag, spatial.error = spatial.error, model = "random", moments = "fullweights")
    	
    	},	
    
    stop("\n Unknown method")
    )    
    
    
    sphtest(femod, remod, ...)
}

sphtest.splm <- function (x, x2, ...){


  ## check that the models have the same specification but different effects
  
if (!all.equal(x$legacy, x2$legacy)) stop("The model are different")
if(x$ef.sph == x2$ef.sph) stop("Effects should be different")

    ran <- match("random", c(x$ef.sph, x2$ef.sph))

if(ran == 1){

	xwith <- x2
	xbetw <- x

	}    

if(ran == 2){

	xwith <- x
	xbetw <- x2

	}    	
    
  ## test on coefficients (excluding SAR)      
  ## model order is irrelevant
  
    tc <- match(names(coef(xwith)), names(coef(xbetw)) )

    coef.wi <- coef(xwith)
    coef.re <- coef(xbetw)[tc]
    vcov.wi <- xwith$vcov
    vcov.re <- xbetw$vcov[tc,tc]
    
    dbeta <- coef.wi - coef.re
    df <- length(dbeta)
    dvcov <- vcov.re - vcov.wi
    stat <- abs(t(dbeta) %*% solve(dvcov) %*% dbeta)
    pval <- pchisq(stat, df = df, lower.tail = FALSE)
    names(stat) <- "chisq"
    parameter <- df
    names(parameter) <- "df"
    data.name <- paste(deparse(x$call$formula))
    alternative <- "one model is inconsistent"
    res <- list(statistic = stat, p.value = pval, parameter = parameter,
        method = "Hausman test for spatial models", data.name = data.name, alternative = alternative)
    class(res) <- "htest"
    return(res)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/spml.R"
spml <- function(formula, data, index=NULL, listw, listw2=listw, na.action,
                 model=c("within","random","pooling"),
                 effect=c("individual","time","twoways"),
                 lag=FALSE, spatial.error=c("b","kkp","none"),
                 ...) {

  ## wrapper function for all ML models

  ## record call
  cl <- match.call()

  ## check class(listw)
  checklw <- function(x) {
# if(model == "within"){
	
	# if("matrix" %in% class(x)) x <- Matrix(x)
		# if("listw" %in% class(x)) x <- listw2dgCMatrix(x)
			# if("Matrix" %in% class(x)) x <- x
	
			  # else stop("'listw' has to be 'listw', 'matrix', or 'Matrix' when model is within")
	
			# }  	
# else{
    
    if(!("listw" %in% class(x))) {
      if("matrix" %in% class(x)) {
        #require(spdep)
        x <- listw2mat(x)
      } 
      else {
        stop("'listw' has to be either a 'listw' or a 'matrix' object")
      }}
      # }
    return(x)
  }

  checklw(listw)
  checklw(listw2)

  ## dimensions check is moved downstream

  switch(match.arg(model), within={
  
    if(lag) {
      model <- switch(match.arg(spatial.error), b="sarar",
                      kkp="sarar", none="lag")
    } else {
    	model <- switch(match.arg(spatial.error), b="error",
                      kkp="error", none="plm")
                      
      if(model == "plm") stop("No spatial component, use plm instead") 
    }
    effects <- switch(match.arg(effect), individual="spfe",
                      time="tpfe", twoways="sptpfe")

    res <- spfeml(formula=formula, data=data, index=index,
                  listw=listw, listw2=listw2, na.action,
                  model=model, effects=effects,
                  cl=cl, ...)
  }, random={
    switch(match.arg(effect),
           time={stop("time random effects not implemented")},
           twoways={stop("twoway random effects not implemented")},
           individual={
             errors <- switch(match.arg(spatial.error),
                              b="semre", kkp="sem2re", none="re")})
    res <- spreml(formula=formula, data=data, index=index,
                  w=listw2mat(listw), w2=listw2mat(listw2),
                  lag=lag, errors=errors, cl=cl, ...)
  }, pooling={
           errors <- switch(match.arg(spatial.error),
                              b="sem", kkp="sem", none="ols")
    res <- spreml(formula=formula, data=data, index=index,
                  w=listw2mat(listw), w2=listw2mat(listw2),
                  lag=lag, errors=errors, cl=cl, ...)
         })

  return(res)
}

    
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/spreml.R"
spreml <-
function (formula, data, index = NULL, w, w2=w, lag = FALSE,
          errors = c("semsrre", "semsr", "srre", "semre",
          "re", "sr", "sem","ols", "sem2srre", "sem2re"),
          pvar = FALSE, hess = FALSE, quiet = TRUE,
          initval = c("zeros", "estimate"),
          x.tol = 1.5e-18, rel.tol = 1e-15, ...)
{
    ## mod from spreml5.R to include experimental versions of functions in /optim

    #require(maxLik)

    trace <- as.numeric(!quiet)
    if (pvar)
        print("<implement pvar>")
    if (!is.null(index)) {
        #require(plm)
        data <- plm.data(data, index)
    }
    index <- data[, 1]
    tindex <- data[, 2]
    cl <- match.call()
    #require(nlme)
    if (!is.matrix(w)) {
        if ("listw" %in% class(w)) {
 #           require(spdep)
 #           w <- listw2mat(w)
        }
        else {
            stop("w has to be either a 'matrix' or a 'listw' object")
        }
    }
    if (dim(data)[[1]] != length(index))
        stop("Non conformable arguments")
#    X <- model.matrix(formula, data = data)
#    y <- model.response(model.frame(formula, data = data))
    pmod <- plm(formula, data, model="pooling")
    X <- model.matrix(pmod)
    y <- pmodel.response(pmod)
    names(index) <- row.names(data)
    ind <- index[which(names(index) %in% row.names(X))]
    tind <- tindex[which(names(index) %in% row.names(X))]
    oo <- order(tind, ind)
    X <- X[oo, , drop=FALSE]
    y <- y[oo]
    ind <- ind[oo]
    tind <- tind[oo]
    n <- length(unique(ind))
    k <- dim(X)[[2]]
    t <- max(tapply(X[, 1], ind, length))
    nT <- length(ind)
#    if (dim(w)[[1]] != n)
#        stop("Non conformable spatial weights") # temporary: adapt to listw or mat
    balanced <- n * t == nT
    if (!balanced)
        stop("Estimation method unavailable for unbalanced panels")
    sv.length <- switch(match.arg(errors), semsrre = 3, semsr = 2,
          srre = 2, semre = 2, re = 1, sr = 1, sem = 1, ols = 0,
          sem2srre = 3, sem2re = 2)
    errors. <- match.arg(errors)
    if (is.numeric(initval)) {
        if (length(initval) != sv.length) {
            stop("Incorrect number of initial values supplied for error vcov parms")
        }
        coef0 <- initval
    }
    else {
        switch(match.arg(initval), zeros = {
            coef0 <- rep(0, sv.length)
        }, estimate = {
            if (nchar(errors.) < 4) {
                stop("Pre-estimation of unique vcov parm is meaningless: \n please select (default) option 'zeros' or supply a scalar")
            }
            coef0 <- NULL
            if (grepl("re", errors.)) {
                REmodel <- REmod(X, y, ind, tind, n, k, t, nT,
                  w, coef0 = 0, hess = FALSE, trace = trace,
                  x.tol = 1.5e-18, rel.tol = 1e-15, ...)
                coef0 <- c(coef0, REmodel$errcomp)
            }
            if (grepl("sr", errors.)) {
                ARmodel <- ssrmod(X, y, ind, tind, n, k, t, nT,
                  w, coef0 = 0, hess = FALSE, trace = trace,
                  x.tol = 1.5e-18, rel.tol = 1e-15, ...)
                coef0 <- c(coef0, ARmodel$errcomp)
            }
            if (grepl("sem", errors.)) {
                SEMmodel <- semmod(X, y, ind, tind, n, k, t,
                  nT, w, coef0 = 0, hess = FALSE, trace = trace,
                  x.tol = 1.5e-18, rel.tol = 1e-15, ...)
                coef0 <- c(coef0, SEMmodel$errcomp)
            }
        })
    }
    if (lag) {
        est.fun <- switch(match.arg(errors), semsrre = {
           saremsrREmod
        }, sem2srre = {
           sarem2srREmod
        }, semsr = {
            saremsrmod
        }, srre = {
            sarsrREmod
        }, semre = {
            saremREmod
        }, re = {
            sarREmod
        }, sr = {
            sarsrmod
        }, sem = {
            saremmod
        }, ols = {
            sarmod
        }, sem2re = {
            sarem2REmod
        })
	  coef0 <- c(coef0, 0)
    } else {
        est.fun <- switch(match.arg(errors), semsrre = {
            semsrREmod
        }, sem2srre = {
           sem2srREmod
        }, semsr = {
            semsrmod
        }, srre = {
            ssrREmod
        }, semre = {
            semREmod
        }, re = {
            REmod
        }, sr = {
            ssrmod
        }, sem = {
            semmod
        }, ols = {
            olsmod
            #stop("No lag and no covariance parameters selected: use lm()")
        }, sem2re = {
            sem2REmod
        })
        arcoef <- NULL
    }
    RES <- est.fun(X, y, ind, tind, n, k, t, nT, w = w, w2 = w2,
                   coef0 = coef0, hess = hess, trace = trace,
                   x.tol = x.tol, rel.tol = rel.tol, ...)
    y.hat <- as.vector(X %*% RES$betas)
    res <- y - y.hat
    nam.rows <- dimnames(X)[[1]]
    names(y.hat) <- nam.rows
    names(res) <- nam.rows
    model.data <- data.frame(cbind(y, X[, -1]))
    dimnames(model.data)[[1]] <- nam.rows
    type <- "random effects ML"
    sigma2v <- RES$sigma2
    sigma2mu <- if(is.null(RES$errcomp["phi"])) {0} else {
      as.numeric(sigma2v*RES$errcomp["phi"])
    }
    sigma2.1 <- sigma2mu + sigma2v
    sigma2 <- list(one = sigma2.1, idios = sigma2v, id = sigma2mu)
    spmod <- list(coefficients = RES$betas, arcoef = RES$arcoef,
        errcomp = RES$errcomp, vcov = RES$covB, vcov.arcoef = RES$covAR,
        vcov.errcomp = RES$covPRL, residuals = res, fitted.values = y.hat,
        sigma2 = sigma2, model = model.data, type = type, call = cl,
        errors = errors, logLik = RES$ll)
    class(spmod) <- "splm"
    return(spmod)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ssrREmod.R"
ssrREmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 3),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## change this to 'bdsmatrix'
    #require(kinship)

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("phi", "psi")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(1e-08, -0.999)
    upper.bounds <- c(1e+09, 0.999)

    ## here observations are reordered like in standard panels, to exploit
    ## the fact that in this case the vcov matrix is block-diagonal

    ## lag y parm kept for compatibility
    wy <- NULL

    ## the sigma matrix is inverted during the GLS step and not before as
    ## in the other cases, to take advantage of specialized methods in the
    ## 'kinship' (migrate to --> 'bdsmatrix'!) package

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    Vmat <- function(rho, t) {
        V1 <- matrix(ncol = t, nrow = t)
        for (i in 1:t) V1[i, ] <- rho^abs(1:t - i)
        V <- (1/(1 - rho^2)) * V1
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t) alfa2(rho) + t - 1
    bSigma <- function(phirho, n, t) {
        phi <- phirho[1]
        rho <- phirho[2]
        Jt <- matrix(1, ncol = t, nrow = t)
        bSigma <- phi * Jt + Vmat(rho, t)
        bSigma
    }
    fullSigma <- function(phirho, n, t) {
        phi <- phirho[1]
        rho <- phirho[2]
        ## psi not used: here passing 3 parms, but works anyway
        ## because psi is last one
        sigma.i <- bSigma(phirho, n, t)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }


    ## likelihood function, both steps included
    ll.c <- function(phirho, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        phi <- phirho[1]
        rho <- phirho[2]
        ## calc sigma (here not inverted)
        sigma <- fullSigma(phirho, n, t)
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, y, sigma)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        uno <- n/2 * log(1 - rho^2)
        due <- -n/2 * log(d2(rho, t) * (1 - rho)^2 * phi + 1)
        tre <- -(n * t)/2 * log(s2e)
        cinque <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + uno + due + tre + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic-ssr from here

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t)
    beta <- GLSstepBDS(X, y, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))
    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    covAR <- NULL
    covPRL <- covTheta

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])    
    arcoef <- NULL
    errcomp <- myparms
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## remember to rearrange any output as x <- x[oo.0]

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/ssrmod.R"
ssrmod <-
function (X, y, ind, tind, n, k, t, nT, w, w2, coef0 = rep(0, 2),
    hess = FALSE, trace = trace, x.tol = 1.5e-18, rel.tol = 1e-15,
    ...)
{

    ## extensive function rewriting, Giovanni Millo 29/09/2010
    ## structure:
    ## a) specific part
    ## - set names, bounds and initial values for parms
    ## - define building blocks for likelihood and GLS as functions of parms
    ## - define likelihood
    ## b) generic part(independent from ll.c() and #parms)
    ## - fetch covariance parms from max lik
    ## - calc last GLS step
    ## - fetch betas
    ## - calc final covariances
    ## - make list of results

    ## change this to 'bdsmatrix'
    #require(kinship)

    ## set names for final parms vectors
    nam.beta <- dimnames(X)[[2]]
    nam.errcomp <- c("psi")

    ## initialize values for optimizer
    myparms0 <- coef0
    ## set bounds for optimizer
    lower.bounds <- c(-0.999)
    upper.bounds <- c(0.999)

    ## here observations are reordered like in standard panels, to exploit
    ## the fact that in this case the vcov matrix is block-diagonal

    ## lag y parm kept for compatibility
    wy <- NULL

    ## the sigma matrix is inverted during the GLS step and not before as
    ## in the other cases, to take advantage of specialized methods in the
    ## 'kinship' (migrate to --> 'bdsmatrix'!) package

    ## GLS step function for bdsmatrices
    GLSstepBDS <- function(X, y, sigma) {
        b.hat <- solve(crossprod(X, solve(sigma, X)), crossprod(X,
            solve(sigma, y)))
        ehat <- y - X %*% b.hat
        sigma2ehat <- crossprod(ehat, solve(sigma, ehat))/(n * t)
        return(list(betahat=b.hat, ehat=ehat, sigma2=sigma2ehat))
    }

    ## rearranging module
    ## save this for eventually re-rearranging output
    oo.0 <- order(tind, ind)
    ## reorder as stacked time series, as in std. panels
    oo <- order(ind, tind)
    X <- X[oo, ]
    y <- y[oo]
    wy <- wy[oo]
    ind <- ind[oo]
    tind <- tind[oo]

    ## modules for likelihood
    Vmat <- function(rho, t) {
        V1 <- matrix(ncol = t, nrow = t)
        for (i in 1:t) V1[i, ] <- rho^abs(1:t - i)
        V <- (1/(1 - rho^2)) * V1
    }
    alfa2 <- function(rho) (1 + rho)/(1 - rho)
    d2 <- function(rho, t) alfa2(rho) + t - 1
    bSigma <- function(phirho, n, t) {
        ## this is kept for standardization, as here bSigma=Vmat
        rho <- phirho[1]
        bSigma <- Vmat(rho, t) # simply
        bSigma
    }
    fullSigma <- function(phirho, n, t) {
        rho <- phirho[1]
        ## psi not used: here passing 2 parms, but works anyway
        ## because psi is last one
        sigma.i <- bSigma(phirho, n, t)
        fullSigma <- bdsmatrix(rep(t, n), rep(as.numeric(sigma.i),
            n))
        fullSigma
    }


    ## likelihood function, both steps included
    ll.c <- function(phirho, y, X, n, t, w, w2, wy) {
        ## retrieve parms
        rho <- phirho[1]
        ## calc sigma (here not inverted)
        sigma <- fullSigma(phirho, n, t)
        ## do GLS step to get e, s2e
        glsres <- GLSstepBDS(X, y, sigma)
        e <- glsres[["ehat"]]
        s2e <- glsres[["sigma2"]]
        ## calc ll
        uno <- n/2 * log(1 - rho^2)
        tre <- -(n * t)/2 * log(s2e)
        cinque <- -1/(2 * s2e) * crossprod(e, solve(sigma, e))
        const <- -(n * t)/2 * log(2 * pi)
        ll.c <- const + uno + tre + cinque
        ## invert sign for minimization
        llc <- -ll.c
    }

    ## generic-ssr from here

    ## max likelihood
    optimum <- nlminb(start = myparms0, objective = ll.c,
                      gradient = NULL, hessian = NULL,
                      y = y, X = X, n = n, t = t, w = w, w2 = w2, wy = wy,
                      scale = 1, control = list(x.tol = x.tol,
                                 rel.tol = rel.tol, trace = trace),
                      lower = lower.bounds, upper = upper.bounds)

    ## log likelihood at optimum (notice inverted sign)
    myll <- -optimum$objective
    ## retrieve optimal parms
    myparms <- optimum$par

    ## one last GLS step at optimal vcov parms
    sigma <- fullSigma(myparms, n, t)
    beta <- GLSstepBDS(X, y, sigma)

    ## final vcov(beta)
    covB <- as.numeric(beta[[3]]) *
        solve(crossprod(X, solve(sigma, X)))
    ## final vcov(errcomp)
    covTheta <- solve(-fdHess(myparms, function(x) -ll.c(x,
        y, X, n, t, w, w2, wy))$Hessian)          # lag-specific line: wy
    nvcovpms <- length(nam.errcomp)
    covAR <- NULL
    covPRL <- covTheta[1:nvcovpms, 1:nvcovpms, drop=FALSE]

    ## final parms
    betas <- as.vector(beta[[1]])
    sigma2 <- as.numeric(beta[["sigma2"]])    
    arcoef <- NULL
    errcomp <- myparms
    names(betas) <- nam.beta
    names(errcomp) <- nam.errcomp

    dimnames(covB) <- list(nam.beta, nam.beta)
    dimnames(covPRL) <- list(names(errcomp), names(errcomp))

    ## remember to rearrange any output as x <- x[oo.0]

    ## result
    RES <- list(betas = betas, arcoef=arcoef, errcomp = errcomp,
                covB = covB, covAR=covAR, covPRL = covPRL, ll = myll,
                sigma2 = sigma2)

    return(RES)
}
#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/summary.splm.R"

`summary.splm` <-
function(object,...){

  ## summary method for splm objects
  ## adds incrementally to the model object, as summary.plm does
  ## structure remains the same for all type but 'spsegm' (symultaneous equations requires a special printing)
            ## to date, only balanced panels are allowed for 'splm'
            balanced <- TRUE #attr(object,"pdim")$balanced
            model.name <- object$type #attr(object,"pmodel")$model
            effect <- "individual" #attr(object,"pmodel")$effect
            ## make coefficients' table if vcov exist
            if (!is.null(object$vcov)) {
                std.err <- sqrt(diag(object$vcov))
               
#if(object$type == "fixed effects sarar")  std.err <- c(object$se.spat, sqrt(diag(object$vcov)))
                 #vcov(object) doesn't work
                b <- coefficients(object)
                z <- b/std.err
                p <- 2*pnorm(abs(z),lower.tail=FALSE)
                CoefTable <- cbind(b,std.err,z,p)
                colnames(CoefTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
                object$CoefTable <- CoefTable
            } 
            else {
                object$CoefTable <- cbind(coefficients(object))
                colnames(object$CoefTable) <- c("Estimate")
            }

            # if (object$type == "fixed effects error" && object$method != "eigen") {
                # lambda <- object$spat.coef
                # object$lambda <- lambda
            # }

            if (object$type == "random effects GM" ) {
                lambda <- object$rho
                object$lambda <- lambda
            }

            if (object$type == "fixed effects GM" ) {
                lambda <- object$rho
                object$lambda <- lambda
            }

            ## make AR coefficient of y's table
            if(!is.null(object$vcov.arcoef)) {
                std.err1 <- sqrt(diag(object$vcov.arcoef))
                ar <- object$arcoef
                z <- ar/std.err1
                p <- 2*pnorm(abs(z),lower.tail=FALSE)
                ARCoefTable <- cbind(ar,std.err1,z,p)
                colnames(ARCoefTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
                object$ARCoefTable <- ARCoefTable
            }


            ## make error comps' table
            if(!is.null(object$vcov.errcomp)) {
                std.err2 <- sqrt(diag(object$vcov.errcomp))
                ec <- object$errcomp
                z <- ec/std.err2
                p <- 2*pnorm(abs(z),lower.tail=FALSE)
                ErrCompTable <- cbind(ec,std.err2,z,p)
                colnames(ErrCompTable) <- c("Estimate","Std. Error","t-value","Pr(>|t|)")
                object$ErrCompTable <- ErrCompTable
            }

            object$ssr <- sum(residuals(object)^2)
            object$tss <- tss(object$model[[1]])
            object$rsqr <- 1-object$ssr/object$tss
            object$fstatistic <- "nil" #Ftest(object)
            class(object) <- c("summary.splm","splm")
            object
        
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/sumres.R"
`sumres` <-
function(x) {
  sr <- summary(residuals(x))
  srm <- mean(residuals(x))
  if (abs(srm) < 1e-10){
    sr <- sr[c(1:3,5:6)]
  }
  sr
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/tss.R"
`tss` <-
function(x) {
  n <- length(as.numeric(x))
  sum(as.numeric(x)^2)-n*mean(as.numeric(x))^2
}

#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/utilities_GM.R"

`arg` <-

function (rhopar, v, verbose = verbose) 

{
	
	#print(v$bigG)

    vv <-  v$bigG %*% c(rhopar[1], rhopar[1]^2, rhopar[2]) - v$smallg

    value <- sum(vv^2)

    if (verbose) 

        cat("function:", value, "rho:", rhopar[1], "sig2:", 

            rhopar[2], "\n")

    value

}



`arg1` <-
function (rhopar, v, ss,SS,T, verbose = verbose) 
{
	Ga<-cbind( (1/(T-1))*ss^2,0)
	Gb<-cbind( 0, SS^2)
	Gc<-rbind(Ga,Gb)
	Gamma<-kronecker(Gc,diag(3)) 
	Gammainv<-solve(Gamma)
    vv <-  v$GG %*% c(rhopar[1], rhopar[1]^2, rhopar[2], rhopar[3]) - v$gg
    value <- t(vv)%*% Gammainv %*% vv
    if (verbose) 
	cat("function:", value, "rho:", rhopar[1], "sig2:", 
		rhopar[2], "\n")
    value
}



`arg2` <-
function (rhopar, v, ss,SS,T,TW, verbose = verbose) 
{
	Ga<-cbind( (1/(T-1))*ss^2,0)
	Gb<-cbind( 0, SS^2)
	Gc<-rbind(Ga,Gb)
	Gamma<-kronecker(Gc,TW) 
	Gammainv<-solve(Gamma)
    vv <-  v$GG %*% c(rhopar[1], rhopar[1]^2, rhopar[2], rhopar[3]) - v$gg
    value <- t(vv)%*% Gammainv %*% vv
    if (verbose) 
	cat("function:", value, "rho:", rhopar[1], "sig2:", 
		rhopar[2], "\n")
    value
}





`fs` <-
function(listw,u,N,T){
	# ind<-seq(1,T)
	# inde<-rep(ind,each=N)
	NT<-N*T
	
	ub <- as.matrix(listw %*%  u)
	ubb <- as.matrix(listw %*%  ub)

# # ub<-lag.listwpanel(listw, u, inde)	
	# ubb<-lag.listwpanel(listw, ub, inde)
	
	inde1<-rep(seq(1,N),T)
	umt<-tapply(u, inde1, mean) 
	ubmt<-tapply(ub, inde1, mean) ####mean over time 
	ubbmt<-tapply(ubb, inde1, mean)

	umNT<-rep(umt,T)
	ubmNT<-rep(ubmt,T)
	ubbmNT<-rep(ubbmt,T)

	Q0ub<-ub-ubmNT
	Q0ubb<-ubb-ubbmNT
	Q0u<-u-umNT
	uQ0ub<-crossprod(u,Q0ub)
	ubQ0ubb<-crossprod(ub,Q0ubb)
	ubbQ0ubb<-crossprod(ubb,Q0ubb)
	ubQ0ub<-crossprod(ub,Q0ub)
	uQ0u<-crossprod(u,Q0u)
	ubbQ0ub<-crossprod(ubb,Q0ub)
	uQ0ubb<-crossprod(u,Q0ubb)
	# trwpw<-sum(unlist(listw$weights)^2)
	trwpw <- sum(as.vector(listw)^2)/T
	
	G1c<-(1/(N*(T-1)))*rbind(2*uQ0ub, 2*ubbQ0ub,(uQ0ubb+ubQ0ub) )
	G2c<- (-1/(N*(T-1)))* rbind(ubQ0ub,ubbQ0ubb,ubQ0ubb)
	G3c<- rbind(1,trwpw/N, 0)
	G<-cbind(G1c,G2c,G3c)	
	g<-(1/(N*(T-1)))*rbind(uQ0u,ubQ0ub,uQ0ub)
#	print(G)
#	print(g)
	output<-list(bigG=G, smallg=g, Q1u=umNT,Q1ub=ubmNT,Q1ubb=ubbmNT, ub=ub,ubb=ubb,TR=trwpw)
}

`fswithin` <-
function(listw, u, N, T){
	# ind<-seq(1,T)
	# inde<-rep(ind,each=N)
	NT<-N*T
	# ub<-lag.listwpanel(listw, u, inde)
	# ubb<-lag.listwpanel(listw, ub, inde)

	ub <- as.matrix(listw %*%  u)
	ubb <- as.matrix(listw %*%  ub)
	# print(ub)	
	uu<-crossprod(u)
	uub<-crossprod(u, ub)
	uubb<-crossprod(u, ubb)
	ububb<-crossprod(ub, ubb)	
	ubbubb<-crossprod(ubb)
	ubub<-crossprod(ub)
	ubbu<-crossprod(ubb, u)
	ubu<-crossprod(ub, u)
	ubbub<-crossprod(ubb, ub)

	# trwpw<-sum(unlist(listw$weights)^2)
	trwpw <- sum(as.vector(listw)^2)/T
	# print(trwpw)
	G1c<-(1/(N*(T-1)))*rbind(2*uub, 2*ubbub,(uubb+ ubub))	
	G2c<- (-1/(N*(T-1)))* rbind(ubub,ubbubb, ububb)
	G3c<- rbind(1,trwpw/N, 0)

	G<-cbind(G1c,G2c,G3c)	
	g<-(1/(N*(T-1)))*rbind(uu, ubub, uub)
	
# print(G)
# print(g)
	output<-list(bigG=G, smallg=g,TR=trwpw)
}


`Ggsararsp` <-
function (W, u, zero.policy = FALSE) 
{
      n <- length(u)
      # tt<-matrix(0,n,1)
      tr<-sum(W^2)
      wu<- as.matrix(W %*% u)
      wwu<- as.matrix(W %*% wu)
      
    	uu <- crossprod(u, u)
    	uwu <- crossprod(u, wu)
 	uwpuw <- crossprod(wu, wu)
    	uwwu <- crossprod(u, wwu)
    	wwupwu <- crossprod(wwu, wu)
    	wwupwwu <- crossprod(wwu, wwu)
    	bigG <- matrix(0, 3, 3)
    	bigG[, 1] <- c(2 * uwu, 2 * wwupwu, (uwwu + uwpuw))/n
    	bigG[, 2] <-  -c(uwpuw, wwupwwu, wwupwu)/n
    	bigG[, 3] <- c(1, tr/n, 0)
    	litg <- c(uu, uwpuw, uwu)/n
    	list(bigG = bigG, litg = litg)
}


`tw` <-
function(W,N){
## depends on listw2dgCMatrix.R
	Ws<- W
	Wst<-t(Ws)
	WpW<-crossprod(Ws)
	WpWWpW<-WpW%*%WpW
	WppW<-Wst+Ws
	WpWWppW<-WpW%*%WppW
	WW<-Ws%*%Ws
	WWpWpW<-WW+WpW
	tr1<-sum(diag(WpW/N))
	tr2<-sum(diag(WpWWpW/N))
	tr3<-sum(diag(WpWWppW/N))
	tr4<-sum(diag(WWpWpW/N))
	TW1c<-rbind(2,2*tr1, 0)
	TW2c<-rbind(2*tr1, 2*tr2,tr3)
	TW3c<-rbind(0, tr3,tr4)
	TW<-cbind(TW1c,TW2c,TW3c)
	out<-list(TW=matrix(TW,3,3))
}

`pw` <-
function(bigG, smallg, Q1u,Q1ub,Q1ubb, u, ub,ubb,N, TR){
	uQ1u<-crossprod(u,Q1u)
	uQ1ub<-crossprod(u,Q1ub)
	ubbQ1ub<-crossprod(ubb,Q1ub)
	ubbQ1ubb<-crossprod(ubb,Q1ubb)
	uQ1ubb<-crossprod(u,Q1ubb)
	ubQ1ub<-crossprod(ub,Q1ub)
	ubQ1ubb<-crossprod(ub,Q1ubb)
	G1c1<-rbind(2*uQ1ub, 2*ubbQ1ub,  (uQ1ubb + ubQ1ub))/N
	G1c2<-rbind(ubQ1ub, ubbQ1ubb, ubQ1ubb)/(-N)
	G1c3<-rbind(1,TR/N,0)
	G1c<-cbind(G1c1,G1c2,rep(0,3),G1c3)
	g1<-rbind(uQ1u, ubQ1ub, uQ1ub)/N
	GG<-rbind(cbind(bigG,rep(0,3)),G1c)	
	gg<-rbind(smallg,g1)
	out<-list(GG=GG,gg=gg)
}


`pwbetween` <-
function(bigG, smallg, u, N, T,TR,listw){

	ub<-as.matrix(listw %*% u)
	ubb<-as.matrix(listw %*% ub)

	uQ1u<-crossprod(u,u)
	uQ1ub<-crossprod(u,ub)
	ubbQ1ub<-crossprod(ubb,ub)
	ubbQ1ubb<-crossprod(ubb,ubb)
	uQ1ubb<-crossprod(u,ubb)
	ubQ1ub<-crossprod(ub,ub)
	ubQ1ubb<-crossprod(ub,ubb)
	G1c1<-rbind(2*uQ1ub, 2*ubbQ1ub,  (uQ1ubb + ubQ1ub))/N
	G1c2<-rbind(ubQ1ub, ubbQ1ubb, ubQ1ubb)/-N
	G1c3<-rbind(1,TR/N,0)
	G1c<-cbind(G1c1,G1c2,rep(0,3),G1c3)
	g1<-rbind(uQ1u, ubQ1ub, uQ1ub)/N
	GG<-rbind(cbind(bigG,rep(0,3)),G1c)
	#print(GG)
	gg<-rbind(smallg,g1)
	out<-list(GG=GG,gg=gg)
}


#line 1 "/tmp/RtmpTIwqA4/R.INSTALL596114216c08/splm/R/vcov.splm.R"
`vcov.splm` <- function(object, ...) return(object$vcov)

